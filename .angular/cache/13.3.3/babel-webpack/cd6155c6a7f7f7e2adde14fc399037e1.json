{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid } from \"@azure/core-tracing\";\nimport { SpanKind } from \"@azure/core-tracing\";\nimport { getUserAgentValue } from \"../util/userAgent\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n/**\n * The programmatic identifier of the tracingPolicy.\n */\n\nexport const tracingPolicyName = \"tracingPolicy\";\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\n\nexport function tracingPolicy(options = {}) {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n  return {\n    name: tracingPolicyName,\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        var _a;\n\n        if (!((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) {\n          return next(request);\n        }\n\n        const span = tryCreateSpan(request, userAgent);\n\n        if (!span) {\n          return next(request);\n        }\n\n        try {\n          const response = yield next(request);\n          tryProcessResponse(span, response);\n          return response;\n        } catch (err) {\n          tryProcessError(span, err);\n          throw err;\n        }\n      })();\n    }\n\n  };\n}\n\nfunction tryCreateSpan(request, userAgent) {\n  var _a, _b, _c;\n\n  try {\n    const createSpanOptions = Object.assign(Object.assign({}, (_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.spanOptions), {\n      kind: SpanKind.CLIENT\n    }); // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n    // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n\n    const {\n      span\n    } = createSpan(`HTTP ${request.method}`, {\n      tracingOptions: Object.assign(Object.assign({}, request.tracingOptions), {\n        spanOptions: createSpanOptions\n      })\n    }); // If the span is not recording, don't do any more work.\n\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n\n    const namespaceFromContext = (_c = (_b = request.tracingOptions) === null || _b === void 0 ? void 0 : _b.tracingContext) === null || _c === void 0 ? void 0 : _c.getValue(Symbol.for(\"az.namespace\"));\n\n    if (typeof namespaceFromContext === \"string\") {\n      span.setAttribute(\"az.namespace\", namespaceFromContext);\n    }\n\n    span.setAttributes({\n      \"http.method\": request.method,\n      \"http.url\": request.url,\n      requestId: request.requestId\n    });\n\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    } // set headers\n\n\n    const spanContext = span.spanContext();\n    const traceParentHeader = getTraceParentHeader(spanContext);\n\n    if (traceParentHeader && isSpanContextValid(spanContext)) {\n      request.headers.set(\"traceparent\", traceParentHeader);\n      const traceState = spanContext.traceState && spanContext.traceState.serialize(); // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n\n      if (traceState) {\n        request.headers.set(\"tracestate\", traceState);\n      }\n    }\n\n    return span;\n  } catch (error) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n    return undefined;\n  }\n}\n\nfunction tryProcessError(span, err) {\n  try {\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: err.message\n    });\n\n    if (err.statusCode) {\n      span.setAttribute(\"http.status_code\", err.statusCode);\n    }\n\n    span.end();\n  } catch (error) {\n    logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n  }\n}\n\nfunction tryProcessResponse(span, response) {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n\n    span.setStatus({\n      code: SpanStatusCode.OK\n    });\n    span.end();\n  } catch (error) {\n    logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n  }\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js"],"names":["SpanStatusCode","createSpanFunction","getTraceParentHeader","isSpanContextValid","SpanKind","getUserAgentValue","logger","createSpan","packagePrefix","namespace","tracingPolicyName","tracingPolicy","options","userAgent","userAgentPrefix","name","sendRequest","request","next","_a","tracingOptions","tracingContext","span","tryCreateSpan","response","tryProcessResponse","err","tryProcessError","_b","_c","createSpanOptions","Object","assign","spanOptions","kind","CLIENT","method","isRecording","end","undefined","namespaceFromContext","getValue","Symbol","for","setAttribute","setAttributes","url","requestId","spanContext","traceParentHeader","headers","set","traceState","serialize","error","warning","message","setStatus","code","ERROR","statusCode","status","serviceRequestId","get","OK"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid, } from \"@azure/core-tracing\";\nimport { SpanKind } from \"@azure/core-tracing\";\nimport { getUserAgentValue } from \"../util/userAgent\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n    packagePrefix: \"\",\n    namespace: \"\",\n});\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options = {}) {\n    const userAgent = getUserAgentValue(options.userAgentPrefix);\n    return {\n        name: tracingPolicyName,\n        async sendRequest(request, next) {\n            var _a;\n            if (!((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) {\n                return next(request);\n            }\n            const span = tryCreateSpan(request, userAgent);\n            if (!span) {\n                return next(request);\n            }\n            try {\n                const response = await next(request);\n                tryProcessResponse(span, response);\n                return response;\n            }\n            catch (err) {\n                tryProcessError(span, err);\n                throw err;\n            }\n        },\n    };\n}\nfunction tryCreateSpan(request, userAgent) {\n    var _a, _b, _c;\n    try {\n        const createSpanOptions = Object.assign(Object.assign({}, (_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.spanOptions), { kind: SpanKind.CLIENT });\n        // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n        // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n        // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n        const { span } = createSpan(`HTTP ${request.method}`, {\n            tracingOptions: Object.assign(Object.assign({}, request.tracingOptions), { spanOptions: createSpanOptions }),\n        });\n        // If the span is not recording, don't do any more work.\n        if (!span.isRecording()) {\n            span.end();\n            return undefined;\n        }\n        const namespaceFromContext = (_c = (_b = request.tracingOptions) === null || _b === void 0 ? void 0 : _b.tracingContext) === null || _c === void 0 ? void 0 : _c.getValue(Symbol.for(\"az.namespace\"));\n        if (typeof namespaceFromContext === \"string\") {\n            span.setAttribute(\"az.namespace\", namespaceFromContext);\n        }\n        span.setAttributes({\n            \"http.method\": request.method,\n            \"http.url\": request.url,\n            requestId: request.requestId,\n        });\n        if (userAgent) {\n            span.setAttribute(\"http.user_agent\", userAgent);\n        }\n        // set headers\n        const spanContext = span.spanContext();\n        const traceParentHeader = getTraceParentHeader(spanContext);\n        if (traceParentHeader && isSpanContextValid(spanContext)) {\n            request.headers.set(\"traceparent\", traceParentHeader);\n            const traceState = spanContext.traceState && spanContext.traceState.serialize();\n            // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n            if (traceState) {\n                request.headers.set(\"tracestate\", traceState);\n            }\n        }\n        return span;\n    }\n    catch (error) {\n        logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n        return undefined;\n    }\n}\nfunction tryProcessError(span, err) {\n    try {\n        span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: err.message,\n        });\n        if (err.statusCode) {\n            span.setAttribute(\"http.status_code\", err.statusCode);\n        }\n        span.end();\n    }\n    catch (error) {\n        logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n}\nfunction tryProcessResponse(span, response) {\n    try {\n        span.setAttribute(\"http.status_code\", response.status);\n        const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n        if (serviceRequestId) {\n            span.setAttribute(\"serviceRequestId\", serviceRequestId);\n        }\n        span.setStatus({\n            code: SpanStatusCode.OK,\n        });\n        span.end();\n    }\n    catch (error) {\n        logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}