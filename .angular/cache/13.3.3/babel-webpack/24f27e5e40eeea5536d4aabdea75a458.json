{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\n\nfunction isNodeReadableStream(body) {\n  return body && typeof body.pipe === \"function\";\n}\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\n\n\nfunction isReadableStream(body) {\n  return Boolean(body && typeof body.getReader === \"function\" && typeof body.tee === \"function\");\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\n\n\nclass FetchHttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  sendRequest(request) {\n    return _asyncToGenerator(function* () {\n      const url = new URL(request.url);\n      const isInsecure = url.protocol !== \"https:\";\n\n      if (isInsecure && !request.allowInsecureConnection) {\n        throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n      }\n\n      if (request.proxySettings) {\n        throw new Error(\"HTTP proxy is not supported in browser environment\");\n      }\n\n      try {\n        return yield makeRequest(request);\n      } catch (e) {\n        throw getError(e, request);\n      }\n    })();\n  }\n\n}\n/**\n * Sends a request\n */\n\n\nfunction makeRequest(_x) {\n  return _makeRequest.apply(this, arguments);\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\n\n\nfunction _makeRequest() {\n  _makeRequest = _asyncToGenerator(function* (request) {\n    const {\n      abortController,\n      abortControllerCleanup\n    } = setupAbortSignal(request);\n\n    try {\n      const headers = buildFetchHeaders(request.headers);\n      const requestBody = buildRequestBody(request);\n      /**\n       * Developers of the future:\n       * Do not set redirect: \"manual\" as part\n       * of request options.\n       * It will not work as you expect.\n       */\n\n      const response = yield fetch(request.url, {\n        body: requestBody,\n        method: request.method,\n        headers: headers,\n        signal: abortController.signal,\n        credentials: request.withCredentials ? \"include\" : \"same-origin\",\n        cache: \"no-store\"\n      });\n      return buildPipelineResponse(response, request);\n    } finally {\n      if (abortControllerCleanup) {\n        abortControllerCleanup();\n      }\n    }\n  });\n  return _makeRequest.apply(this, arguments);\n}\n\nfunction buildPipelineResponse(_x2, _x3) {\n  return _buildPipelineResponse.apply(this, arguments);\n}\n\nfunction _buildPipelineResponse() {\n  _buildPipelineResponse = _asyncToGenerator(function* (httpResponse, request) {\n    var _a, _b;\n\n    const headers = buildPipelineHeaders(httpResponse);\n    const response = {\n      request,\n      headers,\n      status: httpResponse.status\n    };\n    const bodyStream = isReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, request.onDownloadProgress) : httpResponse.body;\n\n    if ( // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n      if (request.enableBrowserStreams) {\n        response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n      } else {\n        const responseStream = new Response(bodyStream);\n        response.blobBody = responseStream.blob();\n      }\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.bodyAsText = yield responseStream.text();\n    }\n\n    return response;\n  });\n  return _buildPipelineResponse.apply(this, arguments);\n}\n\nfunction setupAbortSignal(request) {\n  const abortController = new AbortController(); // Cleanup function\n\n  let abortControllerCleanup;\n  /**\n   * Attach an abort listener to the request\n   */\n\n  let abortListener;\n\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n\n    abortListener = event => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n\n    abortControllerCleanup = () => {\n      var _a;\n\n      if (abortListener) {\n        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  } // If a timeout was passed, call the abort signal once the time elapses\n\n\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n\n  return {\n    abortController,\n    abortControllerCleanup\n  };\n}\n/**\n * Gets the specific error\n */\n\n\nfunction getError(e, request) {\n  var _a;\n\n  if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n      request\n    });\n  }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\n\n\nfunction buildFetchHeaders(pipelineHeaders) {\n  const headers = new Headers();\n\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n\n  return headers;\n}\n\nfunction buildPipelineHeaders(httpResponse) {\n  const responseHeaders = createHttpHeaders();\n\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n\n  return responseHeaders;\n}\n\nfunction buildRequestBody(request) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n\n  return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\n\n\nfunction buildBodyStream(readableStream, onProgress) {\n  let loadedBytes = 0; // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(new TransformStream({\n      transform(chunk, controller) {\n        if (chunk === null) {\n          controller.terminate();\n          return;\n        }\n\n        controller.enqueue(chunk);\n        loadedBytes += chunk.length;\n\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      }\n\n    }));\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      pull(controller) {\n        return _asyncToGenerator(function* () {\n          var _a;\n\n          const {\n            done,\n            value\n          } = yield reader.read(); // When no more data needs to be consumed, break the reading\n\n          if (done || !value) {\n            // Close the stream\n            controller.close();\n            reader.releaseLock();\n            return;\n          }\n\n          loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0; // Enqueue the next data chunk into our target stream\n\n          controller.enqueue(value);\n\n          if (onProgress) {\n            onProgress({\n              loadedBytes\n            });\n          }\n        })();\n      }\n\n    });\n  }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\n\n\nexport function createFetchHttpClient() {\n  return new FetchHttpClient();\n}\n\nfunction isTransformStreamSupported(readableStream) {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/core-rest-pipeline/dist-esm/src/fetchHttpClient.js"],"names":["AbortError","RestError","createHttpHeaders","isNodeReadableStream","body","pipe","isReadableStream","Boolean","getReader","tee","FetchHttpClient","sendRequest","request","url","URL","isInsecure","protocol","allowInsecureConnection","Error","proxySettings","makeRequest","e","getError","abortController","abortControllerCleanup","setupAbortSignal","headers","buildFetchHeaders","requestBody","buildRequestBody","response","fetch","method","signal","credentials","withCredentials","cache","buildPipelineResponse","httpResponse","_a","_b","buildPipelineHeaders","status","bodyStream","buildBodyStream","onDownloadProgress","streamResponseStatusCodes","has","Number","POSITIVE_INFINITY","enableBrowserStreams","browserStreamBody","undefined","responseStream","Response","blobBody","blob","bodyAsText","text","AbortController","abortListener","abortSignal","aborted","event","type","abort","addEventListener","removeEventListener","timeout","setTimeout","name","message","code","REQUEST_SEND_ERROR","pipelineHeaders","Headers","value","append","responseHeaders","set","onUploadProgress","readableStream","onProgress","loadedBytes","isTransformStreamSupported","pipeThrough","TransformStream","transform","chunk","controller","terminate","enqueue","length","reader","ReadableStream","pull","done","read","close","releaseLock","createFetchHttpClient","self"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\nfunction isNodeReadableStream(body) {\n    return body && typeof body.pipe === \"function\";\n}\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\nfunction isReadableStream(body) {\n    return Boolean(body &&\n        typeof body.getReader === \"function\" &&\n        typeof body.tee === \"function\");\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n    /**\n     * Makes a request over an underlying transport layer and returns the response.\n     * @param request - The request to be made.\n     */\n    async sendRequest(request) {\n        const url = new URL(request.url);\n        const isInsecure = url.protocol !== \"https:\";\n        if (isInsecure && !request.allowInsecureConnection) {\n            throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n        }\n        if (request.proxySettings) {\n            throw new Error(\"HTTP proxy is not supported in browser environment\");\n        }\n        try {\n            return await makeRequest(request);\n        }\n        catch (e) {\n            throw getError(e, request);\n        }\n    }\n}\n/**\n * Sends a request\n */\nasync function makeRequest(request) {\n    const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n    try {\n        const headers = buildFetchHeaders(request.headers);\n        const requestBody = buildRequestBody(request);\n        /**\n         * Developers of the future:\n         * Do not set redirect: \"manual\" as part\n         * of request options.\n         * It will not work as you expect.\n         */\n        const response = await fetch(request.url, {\n            body: requestBody,\n            method: request.method,\n            headers: headers,\n            signal: abortController.signal,\n            credentials: request.withCredentials ? \"include\" : \"same-origin\",\n            cache: \"no-store\",\n        });\n        return buildPipelineResponse(response, request);\n    }\n    finally {\n        if (abortControllerCleanup) {\n            abortControllerCleanup();\n        }\n    }\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse, request) {\n    var _a, _b;\n    const headers = buildPipelineHeaders(httpResponse);\n    const response = {\n        request,\n        headers,\n        status: httpResponse.status,\n    };\n    const bodyStream = isReadableStream(httpResponse.body)\n        ? buildBodyStream(httpResponse.body, request.onDownloadProgress)\n        : httpResponse.body;\n    if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) ||\n        ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n        if (request.enableBrowserStreams) {\n            response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n        }\n        else {\n            const responseStream = new Response(bodyStream);\n            response.blobBody = responseStream.blob();\n        }\n    }\n    else {\n        const responseStream = new Response(bodyStream);\n        response.bodyAsText = await responseStream.text();\n    }\n    return response;\n}\nfunction setupAbortSignal(request) {\n    const abortController = new AbortController();\n    // Cleanup function\n    let abortControllerCleanup;\n    /**\n     * Attach an abort listener to the request\n     */\n    let abortListener;\n    if (request.abortSignal) {\n        if (request.abortSignal.aborted) {\n            throw new AbortError(\"The operation was aborted.\");\n        }\n        abortListener = (event) => {\n            if (event.type === \"abort\") {\n                abortController.abort();\n            }\n        };\n        request.abortSignal.addEventListener(\"abort\", abortListener);\n        abortControllerCleanup = () => {\n            var _a;\n            if (abortListener) {\n                (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n            }\n        };\n    }\n    // If a timeout was passed, call the abort signal once the time elapses\n    if (request.timeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n        }, request.timeout);\n    }\n    return { abortController, abortControllerCleanup };\n}\n/**\n * Gets the specific error\n */\nfunction getError(e, request) {\n    var _a;\n    if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n        return e;\n    }\n    else {\n        return new RestError(`Error sending request: ${e.message}`, {\n            code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n            request,\n        });\n    }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n    const headers = new Headers();\n    for (const [name, value] of pipelineHeaders) {\n        headers.append(name, value);\n    }\n    return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n    const responseHeaders = createHttpHeaders();\n    for (const [name, value] of httpResponse.headers) {\n        responseHeaders.set(name, value);\n    }\n    return responseHeaders;\n}\nfunction buildRequestBody(request) {\n    const body = typeof request.body === \"function\" ? request.body() : request.body;\n    if (isNodeReadableStream(body)) {\n        throw new Error(\"Node streams are not supported in browser environment.\");\n    }\n    return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, onProgress) {\n    let loadedBytes = 0;\n    // If the current browser supports pipeThrough we use a TransformStream\n    // to report progress\n    if (isTransformStreamSupported(readableStream)) {\n        return readableStream.pipeThrough(new TransformStream({\n            transform(chunk, controller) {\n                if (chunk === null) {\n                    controller.terminate();\n                    return;\n                }\n                controller.enqueue(chunk);\n                loadedBytes += chunk.length;\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n        }));\n    }\n    else {\n        // If we can't use transform streams, wrap the original stream in a new readable stream\n        // and use pull to enqueue each chunk and report progress.\n        const reader = readableStream.getReader();\n        return new ReadableStream({\n            async pull(controller) {\n                var _a;\n                const { done, value } = await reader.read();\n                // When no more data needs to be consumed, break the reading\n                if (done || !value) {\n                    // Close the stream\n                    controller.close();\n                    reader.releaseLock();\n                    return;\n                }\n                loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n                // Enqueue the next data chunk into our target stream\n                controller.enqueue(value);\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n        });\n    }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n    return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n    return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n"]},"metadata":{},"sourceType":"module"}