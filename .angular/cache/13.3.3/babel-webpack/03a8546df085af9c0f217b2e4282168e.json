{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\n\nexport class XhrHttpClient {\n  sendRequest(request) {\n    var _a;\n\n    const xhr = new XMLHttpRequest();\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    const abortSignal = request.abortSignal;\n\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n\n      const listener = () => {\n        xhr.abort();\n      };\n\n      abortSignal.addEventListener(\"abort\", listener);\n      xhr.addEventListener(\"readystatechange\", () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n\n    if (request.formData) {\n      const formData = request.formData;\n      const requestForm = new FormData();\n\n      const appendFormValue = (key, value) => {\n        if (value && Object.prototype.hasOwnProperty.call(value, \"value\") && Object.prototype.hasOwnProperty.call(value, \"options\")) {\n          requestForm.append(key, value.value, value.options);\n        } else {\n          requestForm.append(key, value);\n        }\n      };\n\n      for (const formKey of Object.keys(formData)) {\n        const formValue = formData[formKey];\n\n        if (Array.isArray(formValue)) {\n          for (let j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n\n      request.body = requestForm;\n      request.formData = undefined;\n      const contentType = request.headers.get(\"Content-Type\");\n\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n\n    for (const header of request.headers.headersArray()) {\n      xhr.setRequestHeader(header.name, header.value);\n    }\n\n    xhr.responseType = ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.size) || request.streamResponseBody ? \"blob\" : \"text\"; // tslint:disable-next-line:no-null-keyword\n\n    xhr.send(request.body === undefined ? null : request.body);\n\n    if (xhr.responseType === \"blob\") {\n      return new Promise((resolve, reject) => {\n        handleBlobResponse(xhr, request, resolve, reject);\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        xhr.addEventListener(\"load\", () => resolve({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          bodyAsText: xhr.responseText\n        }));\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  }\n\n}\n\nfunction handleBlobResponse(xhr, request, res, rej) {\n  xhr.addEventListener(\"readystatechange\", () => {\n    var _a; // Resolve as soon as headers are loaded\n\n\n    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n      if (request.streamResponseBody || ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(xhr.status))) {\n        const blobBody = new Promise((resolve, reject) => {\n          xhr.addEventListener(\"load\", () => {\n            resolve(xhr.response);\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n        res({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          blobBody\n        });\n      } else {\n        xhr.addEventListener(\"load\", () => {\n          // xhr.response is of Blob type if the request is sent with xhr.responseType === \"blob\"\n          // but the status code is not one of the stream response status codes,\n          // so treat it as text and convert from Blob to text\n          if (xhr.response) {\n            // Blob.text() is not supported in IE so using FileReader instead\n            const reader = new FileReader();\n\n            reader.onload = function (e) {\n              var _a;\n\n              const text = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n              res({\n                request,\n                status: xhr.status,\n                headers: parseHeaders(xhr),\n                bodyAsText: text\n              });\n            };\n\n            reader.onerror = function (_e) {\n              rej(reader.error);\n            };\n\n            reader.readAsText(xhr.response, \"UTF-8\");\n          } else {\n            res({\n              request,\n              status: xhr.status,\n              headers: parseHeaders(xhr)\n            });\n          }\n        });\n      }\n    }\n  });\n}\n\nfunction addProgressListener(xhr, listener) {\n  if (listener) {\n    xhr.addEventListener(\"progress\", rawEvent => listener({\n      loadedBytes: rawEvent.loaded\n    }));\n  }\n} // exported locally for testing\n\n\nexport function parseHeaders(xhr) {\n  const responseHeaders = new HttpHeaders();\n  const headerLines = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n\n  for (const line of headerLines) {\n    const index = line.indexOf(\":\");\n    const headerName = line.slice(0, index);\n    const headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n\n  return responseHeaders;\n}\n\nfunction rejectOnTerminalEvent(request, xhr, reject) {\n  xhr.addEventListener(\"error\", () => reject(new RestError(`Failed to send request to ${request.url}`, RestError.REQUEST_SEND_ERROR, undefined, request)));\n  const abortError = new AbortError(\"The operation was aborted.\");\n  xhr.addEventListener(\"abort\", () => reject(abortError));\n  xhr.addEventListener(\"timeout\", () => reject(abortError));\n} //# sourceMappingURL=xhrHttpClient.js.map","map":null,"metadata":{},"sourceType":"module"}