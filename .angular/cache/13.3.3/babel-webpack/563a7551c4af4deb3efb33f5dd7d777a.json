{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\n\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Default authorize request handler\n */\n\nfunction defaultAuthorizeRequest(_x) {\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\n\n\nfunction _defaultAuthorizeRequest() {\n  _defaultAuthorizeRequest = _asyncToGenerator(function* (options) {\n    const {\n      scopes,\n      getAccessToken,\n      request\n    } = options;\n    const getTokenOptions = {\n      abortSignal: request.abortSignal,\n      tracingOptions: request.tracingOptions\n    };\n    const accessToken = yield getAccessToken(scopes, getTokenOptions);\n\n    if (accessToken) {\n      options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n  });\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n\nfunction getChallenge(response) {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n\n  return;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\n\n\nexport function bearerTokenAuthenticationPolicy(options) {\n  var _a;\n\n  const {\n    credential,\n    scopes,\n    challengeCallbacks,\n    logger\n  } = options;\n  const callbacks = Object.assign({\n    authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge\n  }, challengeCallbacks); // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n\n  const getAccessToken = credential ? createTokenCycler(credential\n  /* , options */\n  ) : () => Promise.resolve(null);\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (!request.url.toLowerCase().startsWith(\"https://\")) {\n          throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n        }\n\n        yield callbacks.authorizeRequest({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          getAccessToken,\n          logger\n        });\n        let response;\n        let error;\n\n        try {\n          response = yield next(request);\n        } catch (err) {\n          error = err;\n          response = err.response;\n        }\n\n        if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {\n          // processes challenge\n          const shouldSendRequest = yield callbacks.authorizeRequestOnChallenge({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            response,\n            getAccessToken,\n            logger\n          });\n\n          if (shouldSendRequest) {\n            return next(request);\n          }\n        }\n\n        if (error) {\n          throw error;\n        } else {\n          return response;\n        }\n      })();\n    }\n\n  };\n} //# sourceMappingURL=bearerTokenAuthenticationPolicy.js.map","map":null,"metadata":{},"sourceType":"module"}