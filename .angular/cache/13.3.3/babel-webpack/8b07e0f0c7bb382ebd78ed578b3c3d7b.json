{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost } from \"../constants\";\nimport { createSpan } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\n\nexport function getIdentityClientAuthorityHost(options) {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost; // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n\n  if (isNode) {\n    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n  } // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n\n\n  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\n\nexport class IdentityClient extends ServiceClient {\n  constructor(options) {\n    var _a;\n\n    const packageDetails = `azsdk-js-identity/2.0.4`;\n    const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;\n    const baseUri = getIdentityClientAuthorityHost(options);\n\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n\n    super(Object.assign(Object.assign({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3\n      }\n    }, options), {\n      userAgentOptions: {\n        userAgentPrefix\n      },\n      baseUri\n    }));\n    this.authorityHost = baseUri;\n    this.abortControllers = new Map();\n  }\n\n  sendTokenRequest(request, expiresOnParser) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      logger.info(`IdentityClient: sending token request to [${request.url}]`);\n      const response = yield _this.sendRequest(request);\n\n      expiresOnParser = expiresOnParser || (responseBody => {\n        return Date.now() + responseBody.expires_in * 1000;\n      });\n\n      if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n        const parsedBody = JSON.parse(response.bodyAsText);\n\n        if (!parsedBody.access_token) {\n          return null;\n        }\n\n        const token = {\n          accessToken: {\n            token: parsedBody.access_token,\n            expiresOnTimestamp: expiresOnParser(parsedBody)\n          },\n          refreshToken: parsedBody.refresh_token\n        };\n        logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n        return token;\n      } else {\n        const error = new AuthenticationError(response.status, response.bodyAsText);\n        logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n        throw error;\n      }\n    })();\n  }\n\n  refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (refreshToken === undefined) {\n        return null;\n      }\n\n      logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"IdentityClient-refreshAccessToken\", options);\n      const refreshParams = {\n        grant_type: \"refresh_token\",\n        client_id: clientId,\n        refresh_token: refreshToken,\n        scope: scopes\n      };\n\n      if (clientSecret !== undefined) {\n        refreshParams.client_secret = clientSecret;\n      }\n\n      const query = new URLSearchParams(refreshParams);\n\n      try {\n        const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n        const request = createPipelineRequest({\n          url: `${_this2.authorityHost}/${tenantId}/${urlSuffix}`,\n          method: \"POST\",\n          body: query.toString(),\n          abortSignal: options && options.abortSignal,\n          headers: createHttpHeaders({\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n          }),\n          tracingOptions: updatedOptions === null || updatedOptions === void 0 ? void 0 : updatedOptions.tracingOptions\n        });\n        const response = yield _this2.sendTokenRequest(request, expiresOnParser);\n        logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n        return response;\n      } catch (err) {\n        if (err.name === AuthenticationErrorName && err.errorResponse.error === \"interaction_required\") {\n          // It's likely that the refresh token has expired, so\n          // return null so that the credential implementation will\n          // initiate the authentication flow again.\n          logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: err.message\n          });\n          return null;\n        } else {\n          logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: err.message\n          });\n          throw err;\n        }\n      } finally {\n        span.end();\n      }\n    })();\n  } // Here is a custom layer that allows us to abort requests that go through MSAL,\n  // since MSAL doesn't allow us to pass options all the way through.\n\n\n  generateAbortSignal(correlationId) {\n    const controller = new AbortController();\n    const controllers = this.abortControllers.get(correlationId) || [];\n    controllers.push(controller);\n    this.abortControllers.set(correlationId, controllers);\n    const existingOnAbort = controller.signal.onabort;\n\n    controller.signal.onabort = (...params) => {\n      this.abortControllers.set(correlationId, undefined);\n\n      if (existingOnAbort) {\n        existingOnAbort(...params);\n      }\n    };\n\n    return controller.signal;\n  }\n\n  abortRequests(correlationId) {\n    const key = correlationId || noCorrelationId;\n    const controllers = [...(this.abortControllers.get(key) || []), // MSAL passes no correlation ID to the get requests...\n    ...(this.abortControllers.get(noCorrelationId) || [])];\n\n    if (!controllers.length) {\n      return;\n    }\n\n    for (const controller of controllers) {\n      controller.abort();\n    }\n\n    this.abortControllers.set(key, undefined);\n  }\n\n  getCorrelationId(options) {\n    var _a;\n\n    const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map(part => part.split(\"=\")).find(([key]) => key === \"client-request-id\");\n    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n  } // The MSAL network module methods follow\n\n\n  sendGetRequestAsync(url, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const request = createPipelineRequest({\n        url,\n        method: \"GET\",\n        body: options === null || options === void 0 ? void 0 : options.body,\n        headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n        abortSignal: _this3.generateAbortSignal(noCorrelationId)\n      });\n      const response = yield _this3.sendRequest(request);\n      return {\n        body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n        headers: response.headers.toJSON(),\n        status: response.status\n      };\n    })();\n  }\n\n  sendPostRequestAsync(url, options) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const request = createPipelineRequest({\n        url,\n        method: \"POST\",\n        body: options === null || options === void 0 ? void 0 : options.body,\n        headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n        // MSAL doesn't send the correlation ID on the get requests.\n        abortSignal: _this4.generateAbortSignal(_this4.getCorrelationId(options))\n      });\n      const response = yield _this4.sendRequest(request);\n      return {\n        body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n        headers: response.headers.toJSON(),\n        status: response.status\n      };\n    })();\n  }\n\n} //# sourceMappingURL=identityClient.js.map","map":null,"metadata":{},"sourceType":"module"}