{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline\";\nimport { flattenResponse } from \"./utils\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nimport { getRequestUrl } from \"./urlHelpers\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\n\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param credential - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options = {}) {\n    var _a;\n\n    this._requestContentType = options.requestContentType;\n    this._baseUri = options.baseUri;\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n\n    if ((_a = options.additionalPolicies) === null || _a === void 0 ? void 0 : _a.length) {\n      for (const {\n        policy,\n        position\n      } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase\n        });\n      }\n    }\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n\n\n  sendRequest(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.pipeline.sendRequest(_this._httpClient, request);\n    })();\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n\n\n  sendOperationRequest(operationArguments, operationSpec) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const baseUri = operationSpec.baseUrl || _this2._baseUri;\n\n      if (!baseUri) {\n        throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n      } // Templatized URLs sometimes reference properties on the ServiceClient child class,\n      // so we have to pass `this` below in order to search these properties if they're\n      // not part of OperationArguments\n\n\n      const url = getRequestUrl(baseUri, operationSpec, operationArguments, _this2);\n      const request = createPipelineRequest({\n        url\n      });\n      request.method = operationSpec.httpMethod;\n      const operationInfo = getOperationRequestInfo(request);\n      operationInfo.operationSpec = operationSpec;\n      operationInfo.operationArguments = operationArguments;\n      const contentType = operationSpec.contentType || _this2._requestContentType;\n\n      if (contentType && operationSpec.requestBody) {\n        request.headers.set(\"Content-Type\", contentType);\n      }\n\n      const options = operationArguments.options;\n\n      if (options) {\n        const requestOptions = options.requestOptions;\n\n        if (requestOptions) {\n          if (requestOptions.timeout) {\n            request.timeout = requestOptions.timeout;\n          }\n\n          if (requestOptions.onUploadProgress) {\n            request.onUploadProgress = requestOptions.onUploadProgress;\n          }\n\n          if (requestOptions.onDownloadProgress) {\n            request.onDownloadProgress = requestOptions.onDownloadProgress;\n          }\n\n          if (requestOptions.shouldDeserialize !== undefined) {\n            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n          }\n\n          if (requestOptions.allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n          }\n        }\n\n        if (options.abortSignal) {\n          request.abortSignal = options.abortSignal;\n        }\n\n        if (options.tracingOptions) {\n          request.tracingOptions = options.tracingOptions;\n        }\n      }\n\n      if (_this2._allowInsecureConnection) {\n        request.allowInsecureConnection = true;\n      }\n\n      if (request.streamResponseStatusCodes === undefined) {\n        request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n      }\n\n      try {\n        const rawResponse = yield _this2.sendRequest(request);\n        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n\n        if (options === null || options === void 0 ? void 0 : options.onResponse) {\n          options.onResponse(rawResponse, flatResponse);\n        }\n\n        return flatResponse;\n      } catch (error) {\n        if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n          const rawResponse = error.response;\n          const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n          error.details = flatResponse;\n\n          if (options === null || options === void 0 ? void 0 : options.onResponse) {\n            options.onResponse(rawResponse, flatResponse, error);\n          }\n        }\n\n        throw error;\n      }\n    })();\n  }\n\n}\n\nfunction createDefaultPipeline(options) {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions = options.credential && credentialScopes ? {\n    credentialScopes,\n    credential: options.credential\n  } : undefined;\n  return createClientPipeline(Object.assign(Object.assign({}, options), {\n    credentialOptions\n  }));\n}\n\nfunction getCredentialScopes(options) {\n  if (options.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes) ? scopes.map(scope => new URL(scope).toString()) : new URL(scopes).toString();\n  }\n\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(`When using credentials, the ServiceClientOptions must contain either a baseUri or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/core-client/dist-esm/src/serviceClient.js"],"names":["createPipelineRequest","createClientPipeline","flattenResponse","getCachedDefaultHttpClient","getOperationRequestInfo","getRequestUrl","getStreamingResponseStatusCodes","ServiceClient","constructor","options","_a","_requestContentType","requestContentType","_baseUri","baseUri","_allowInsecureConnection","allowInsecureConnection","_httpClient","httpClient","pipeline","createDefaultPipeline","additionalPolicies","length","policy","position","afterPhase","undefined","addPolicy","sendRequest","request","sendOperationRequest","operationArguments","operationSpec","baseUrl","Error","url","method","httpMethod","operationInfo","contentType","requestBody","headers","set","requestOptions","timeout","onUploadProgress","onDownloadProgress","shouldDeserialize","abortSignal","tracingOptions","streamResponseStatusCodes","rawResponse","flatResponse","responses","status","onResponse","error","response","statusCode","details","credentialScopes","getCredentialScopes","credentialOptions","credential","Object","assign","scopes","Array","isArray","map","scope","URL","toString"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createPipelineRequest, } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline\";\nimport { flattenResponse } from \"./utils\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nimport { getRequestUrl } from \"./urlHelpers\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n    /**\n     * The ServiceClient constructor\n     * @param credential - The credentials used for authentication with the service.\n     * @param options - The service client options that govern the behavior of the client.\n     */\n    constructor(options = {}) {\n        var _a;\n        this._requestContentType = options.requestContentType;\n        this._baseUri = options.baseUri;\n        this._allowInsecureConnection = options.allowInsecureConnection;\n        this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n        this.pipeline = options.pipeline || createDefaultPipeline(options);\n        if ((_a = options.additionalPolicies) === null || _a === void 0 ? void 0 : _a.length) {\n            for (const { policy, position } of options.additionalPolicies) {\n                // Sign happens after Retry and is commonly needed to occur\n                // before policies that intercept post-retry.\n                const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n                this.pipeline.addPolicy(policy, {\n                    afterPhase,\n                });\n            }\n        }\n    }\n    /**\n     * Send the provided httpRequest.\n     */\n    async sendRequest(request) {\n        return this.pipeline.sendRequest(this._httpClient, request);\n    }\n    /**\n     * Send an HTTP request that is populated using the provided OperationSpec.\n     * @typeParam T - The typed result of the request, based on the OperationSpec.\n     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n     * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n     */\n    async sendOperationRequest(operationArguments, operationSpec) {\n        const baseUri = operationSpec.baseUrl || this._baseUri;\n        if (!baseUri) {\n            throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n        }\n        // Templatized URLs sometimes reference properties on the ServiceClient child class,\n        // so we have to pass `this` below in order to search these properties if they're\n        // not part of OperationArguments\n        const url = getRequestUrl(baseUri, operationSpec, operationArguments, this);\n        const request = createPipelineRequest({\n            url,\n        });\n        request.method = operationSpec.httpMethod;\n        const operationInfo = getOperationRequestInfo(request);\n        operationInfo.operationSpec = operationSpec;\n        operationInfo.operationArguments = operationArguments;\n        const contentType = operationSpec.contentType || this._requestContentType;\n        if (contentType && operationSpec.requestBody) {\n            request.headers.set(\"Content-Type\", contentType);\n        }\n        const options = operationArguments.options;\n        if (options) {\n            const requestOptions = options.requestOptions;\n            if (requestOptions) {\n                if (requestOptions.timeout) {\n                    request.timeout = requestOptions.timeout;\n                }\n                if (requestOptions.onUploadProgress) {\n                    request.onUploadProgress = requestOptions.onUploadProgress;\n                }\n                if (requestOptions.onDownloadProgress) {\n                    request.onDownloadProgress = requestOptions.onDownloadProgress;\n                }\n                if (requestOptions.shouldDeserialize !== undefined) {\n                    operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n                }\n                if (requestOptions.allowInsecureConnection) {\n                    request.allowInsecureConnection = true;\n                }\n            }\n            if (options.abortSignal) {\n                request.abortSignal = options.abortSignal;\n            }\n            if (options.tracingOptions) {\n                request.tracingOptions = options.tracingOptions;\n            }\n        }\n        if (this._allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n        }\n        if (request.streamResponseStatusCodes === undefined) {\n            request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n        }\n        try {\n            const rawResponse = await this.sendRequest(request);\n            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n            if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                options.onResponse(rawResponse, flatResponse);\n            }\n            return flatResponse;\n        }\n        catch (error) {\n            if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n                const rawResponse = error.response;\n                const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n                error.details = flatResponse;\n                if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                    options.onResponse(rawResponse, flatResponse, error);\n                }\n            }\n            throw error;\n        }\n    }\n}\nfunction createDefaultPipeline(options) {\n    const credentialScopes = getCredentialScopes(options);\n    const credentialOptions = options.credential && credentialScopes\n        ? { credentialScopes, credential: options.credential }\n        : undefined;\n    return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));\n}\nfunction getCredentialScopes(options) {\n    if (options.credentialScopes) {\n        const scopes = options.credentialScopes;\n        return Array.isArray(scopes)\n            ? scopes.map((scope) => new URL(scope).toString())\n            : new URL(scopes).toString();\n    }\n    if (options.baseUri) {\n        return `${options.baseUri}/.default`;\n    }\n    if (options.credential && !options.credentialScopes) {\n        throw new Error(`When using credentials, the ServiceClientOptions must contain either a baseUri or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n    }\n    return undefined;\n}\n"]},"metadata":{},"sourceType":"module"}