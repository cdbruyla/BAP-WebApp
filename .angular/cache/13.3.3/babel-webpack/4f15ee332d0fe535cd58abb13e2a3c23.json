{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { Constants } from \"../util/constants\";\nimport { DEFAULT_CLIENT_MAX_RETRY_COUNT } from \"../util/throttlingRetryStrategy\";\nimport { delay } from \"../util/delay\";\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n * @returns\n */\n\nexport function throttlingRetryPolicy() {\n  return {\n    create: (nextPolicy, options) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    }\n  };\n}\nconst StandardAbortMessage = \"The operation was aborted.\";\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\n\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, _handleResponse) {\n    super(nextPolicy, options);\n    this.numberOfRetries = 0;\n    this._handleResponse = _handleResponse || this._defaultResponseHandler;\n  }\n\n  sendRequest(httpRequest) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const response = yield _this._nextPolicy.sendRequest(httpRequest.clone());\n\n      if (response.status !== StatusCodes.TooManyRequests && response.status !== StatusCodes.ServiceUnavailable) {\n        return response;\n      } else {\n        return _this._handleResponse(httpRequest, response);\n      }\n    })();\n  }\n\n  _defaultResponseHandler(httpRequest, httpResponse) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);\n\n      if (retryAfterHeader) {\n        const delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);\n\n        if (delayInMs) {\n          _this2.numberOfRetries += 1;\n          yield delay(delayInMs, undefined, {\n            abortSignal: httpRequest.abortSignal,\n            abortErrorMsg: StandardAbortMessage\n          });\n\n          if ((_a = httpRequest.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n            throw new AbortError(StandardAbortMessage);\n          }\n\n          if (_this2.numberOfRetries < DEFAULT_CLIENT_MAX_RETRY_COUNT) {\n            return _this2.sendRequest(httpRequest);\n          } else {\n            return _this2._nextPolicy.sendRequest(httpRequest);\n          }\n        }\n      }\n\n      return httpResponse;\n    })();\n  }\n\n  static parseRetryAfterHeader(headerValue) {\n    const retryAfterInSeconds = Number(headerValue);\n\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n\n  static parseDateRetryAfterHeader(headerValue) {\n    try {\n      const now = Date.now();\n      const date = Date.parse(headerValue);\n      const diff = date - now;\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  }\n\n} //# sourceMappingURL=throttlingRetryPolicy.js.map","map":null,"metadata":{},"sourceType":"module"}