{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getPollingUrl, inferLroMode, isUnexpectedInitialResponse } from \"./requestUtils\";\nimport { isBodyPollingDone, processBodyPollingOperationResult } from \"./bodyPolling\";\nimport { logger } from \"./logger\";\nimport { processLocationPollingOperationResult } from \"./locationPolling\";\nimport { processPassthroughOperationResult } from \"./passthrough\";\n/**\n * creates a stepping function that maps an LRO state to another.\n */\n\nexport function createGetLroStatusFromResponse(lroPrimitives, config, lroResourceLocationConfig) {\n  switch (config.mode) {\n    case \"Location\":\n      {\n        return processLocationPollingOperationResult(lroPrimitives, config.resourceLocation, lroResourceLocationConfig);\n      }\n\n    case \"Body\":\n      {\n        return processBodyPollingOperationResult;\n      }\n\n    default:\n      {\n        return processPassthroughOperationResult;\n      }\n  }\n}\n/**\n * Creates a polling operation.\n */\n\nexport function createPoll(lroPrimitives) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (path, pollerConfig, getLroStatusFromResponse) {\n      const response = yield lroPrimitives.sendPollRequest(path);\n      const retryAfter = response.rawResponse.headers[\"retry-after\"];\n\n      if (retryAfter !== undefined) {\n        // Retry-After header value is either in HTTP date format, or in seconds\n        const retryAfterInSeconds = parseInt(retryAfter);\n        pollerConfig.intervalInMs = isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter), pollerConfig.intervalInMs) : retryAfterInSeconds * 1000;\n      }\n\n      return getLroStatusFromResponse(response);\n    });\n\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction calculatePollingIntervalFromDate(retryAfterDate, defaultIntervalInMs) {\n  const timeNow = Math.floor(new Date().getTime());\n  const retryAfterTime = retryAfterDate.getTime();\n\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n\n  return defaultIntervalInMs;\n}\n/**\n * Creates a callback to be used to initialize the polling operation state.\n * @param state - of the polling operation\n * @param operationSpec - of the LRO\n * @param callback - callback to be called when the operation is done\n * @returns callback that initializes the state of the polling operation\n */\n\n\nexport function createInitializeState(state, requestPath, requestMethod) {\n  return response => {\n    if (isUnexpectedInitialResponse(response.rawResponse)) return true;\n    state.initialRawResponse = response.rawResponse;\n    state.isStarted = true;\n    state.pollingURL = getPollingUrl(state.initialRawResponse, requestPath);\n    state.config = inferLroMode(requestPath, requestMethod, state.initialRawResponse);\n    /** short circuit polling if body polling is done in the initial request */\n\n    if (state.config.mode === undefined || state.config.mode === \"Body\" && isBodyPollingDone(state.initialRawResponse)) {\n      state.result = response.flatResponse;\n      state.isCompleted = true;\n    }\n\n    logger.verbose(`LRO: initial state: ${JSON.stringify(state)}`);\n    return Boolean(state.isCompleted);\n  };\n} //# sourceMappingURL=stateMachine.js.map","map":null,"metadata":{},"sourceType":"module"}