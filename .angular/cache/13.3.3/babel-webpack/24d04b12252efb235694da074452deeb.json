{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { createSpan } from \"../util/tracing\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { credentialLogger, formatSuccess, formatError } from \"../util/logging\";\n/**\n * @internal\n */\n\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\n\nexport class ChainedTokenCredential {\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```javascript\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  constructor(...sources) {\n    /**\n     * The message to use when the chained token fails to get a token\n     */\n    this.UnavailableMessage = \"ChainedTokenCredential => failed to retrieve a token from the included credentials\";\n    this._sources = [];\n    this._sources = sources;\n  }\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n\n\n  getToken(scopes, options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let token = null;\n      let successfulCredentialName = \"\";\n      const errors = [];\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ChainedTokenCredential.getToken\", options);\n\n      for (let i = 0; i < _this._sources.length && token === null; i++) {\n        try {\n          token = yield _this._sources[i].getToken(scopes, updatedOptions);\n          successfulCredentialName = _this._sources[i].constructor.name;\n        } catch (err) {\n          if (err.name === \"CredentialUnavailableError\" || err.name === \"AuthenticationRequiredError\") {\n            errors.push(err);\n          } else {\n            logger.getToken.info(formatError(scopes, err));\n            throw err;\n          }\n        }\n      }\n\n      if (!token && errors.length > 0) {\n        const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message\n        });\n        logger.getToken.info(formatError(scopes, err));\n        throw err;\n      }\n\n      span.end();\n      logger.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);\n\n      if (token === null) {\n        throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n      }\n\n      return token;\n    })();\n  }\n\n} //# sourceMappingURL=chainedTokenCredential.js.map","map":null,"metadata":{},"sourceType":"module"}