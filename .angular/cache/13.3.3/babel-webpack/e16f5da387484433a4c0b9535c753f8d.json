{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\n\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\n\nexport function retryPolicy(strategies, options = {\n  maxRetries: DEFAULT_RETRY_POLICY_COUNT\n}) {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n\n        let response;\n        let responseError;\n        let retryCount = -1; // eslint-disable-next-line no-constant-condition\n\n        retryRequest: while (true) {\n          retryCount += 1;\n          response = undefined;\n          responseError = undefined;\n\n          try {\n            logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n            response = yield next(request);\n            logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n          } catch (e) {\n            logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId); // RestErrors are valid targets for the retry strategies.\n            // If none of the retry strategies can work with them, they will be thrown later in this policy.\n            // If the received error is not a RestError, it is immediately thrown.\n\n            responseError = e;\n\n            if (!e || responseError.name !== \"RestError\") {\n              throw e;\n            }\n\n            response = responseError.response;\n          }\n\n          if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n            logger.error(`Retry ${retryCount}: Request aborted.`);\n            const abortError = new AbortError();\n            throw abortError;\n          }\n\n          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n            logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n\n            if (responseError) {\n              throw responseError;\n            } else if (response) {\n              return response;\n            } else {\n              throw new Error(\"Maximum retries reached with no response or error to throw\");\n            }\n          }\n\n          logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n\n          strategiesLoop: for (const strategy of strategies) {\n            const strategyLogger = strategy.logger || retryPolicyLogger;\n            strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n            const modifiers = strategy.retry({\n              retryCount,\n              response,\n              responseError\n            });\n\n            if (modifiers.skipStrategy) {\n              strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n              continue strategiesLoop;\n            }\n\n            const {\n              errorToThrow,\n              retryAfterInMs,\n              redirectTo\n            } = modifiers;\n\n            if (errorToThrow) {\n              strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n              throw errorToThrow;\n            }\n\n            if (retryAfterInMs || retryAfterInMs === 0) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n              yield delay(retryAfterInMs, undefined, {\n                abortSignal: request.abortSignal\n              });\n              continue retryRequest;\n            }\n\n            if (redirectTo) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n              request.url = redirectTo;\n              continue retryRequest;\n            }\n          }\n\n          if (responseError) {\n            logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n            throw responseError;\n          }\n\n          if (response) {\n            logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n            return response;\n          } // If all the retries skip and there's no response,\n          // we're still in the retry loop, so a new request will be sent\n          // until `maxRetries` is reached.\n\n        }\n      })();\n    }\n\n  };\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js"],"names":["delay","createClientLogger","AbortError","DEFAULT_RETRY_POLICY_COUNT","retryPolicyLogger","retryPolicyName","retryPolicy","strategies","options","maxRetries","logger","name","sendRequest","request","next","_a","_b","response","responseError","retryCount","retryRequest","undefined","info","requestId","e","error","abortSignal","aborted","abortError","Error","length","strategiesLoop","strategy","strategyLogger","modifiers","retry","skipStrategy","errorToThrow","retryAfterInMs","redirectTo","url"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {\n    const logger = options.logger || retryPolicyLogger;\n    return {\n        name: retryPolicyName,\n        async sendRequest(request, next) {\n            var _a, _b;\n            let response;\n            let responseError;\n            let retryCount = -1;\n            // eslint-disable-next-line no-constant-condition\n            retryRequest: while (true) {\n                retryCount += 1;\n                response = undefined;\n                responseError = undefined;\n                try {\n                    logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n                    response = await next(request);\n                    logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n                }\n                catch (e) {\n                    logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n                    // RestErrors are valid targets for the retry strategies.\n                    // If none of the retry strategies can work with them, they will be thrown later in this policy.\n                    // If the received error is not a RestError, it is immediately thrown.\n                    responseError = e;\n                    if (!e || responseError.name !== \"RestError\") {\n                        throw e;\n                    }\n                    response = responseError.response;\n                }\n                if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                    logger.error(`Retry ${retryCount}: Request aborted.`);\n                    const abortError = new AbortError();\n                    throw abortError;\n                }\n                if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n                    logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n                    if (responseError) {\n                        throw responseError;\n                    }\n                    else if (response) {\n                        return response;\n                    }\n                    else {\n                        throw new Error(\"Maximum retries reached with no response or error to throw\");\n                    }\n                }\n                logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n                strategiesLoop: for (const strategy of strategies) {\n                    const strategyLogger = strategy.logger || retryPolicyLogger;\n                    strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n                    const modifiers = strategy.retry({\n                        retryCount,\n                        response,\n                        responseError,\n                    });\n                    if (modifiers.skipStrategy) {\n                        strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n                        continue strategiesLoop;\n                    }\n                    const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n                    if (errorToThrow) {\n                        strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n                        throw errorToThrow;\n                    }\n                    if (retryAfterInMs || retryAfterInMs === 0) {\n                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n                        await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n                        continue retryRequest;\n                    }\n                    if (redirectTo) {\n                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n                        request.url = redirectTo;\n                        continue retryRequest;\n                    }\n                }\n                if (responseError) {\n                    logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n                    throw responseError;\n                }\n                if (response) {\n                    logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n                    return response;\n                }\n                // If all the retries skip and there's no response,\n                // we're still in the retry loop, so a new request will be sent\n                // until `maxRetries` is reached.\n            }\n        },\n    };\n}\n"]},"metadata":{},"sourceType":"module"}