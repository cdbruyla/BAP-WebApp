{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"@azure/core-http\";\nimport { HTTP_VERSION_1_1, HTTP_LINE_ENDING, HeaderConstants, HTTPURLConnection } from \"./utils/constants\";\nimport { getBodyAsText } from \"./BatchUtils\";\nimport { logger } from \"./log\";\nconst HTTP_HEADER_DELIMITER = \": \";\nconst SPACE_DELIMITER = \" \";\nconst NOT_FOUND = -1;\n/**\n * Util class for parsing batch response.\n */\n\nexport class BatchResponseParser {\n  constructor(batchResponse, subRequests) {\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType.split(\"=\")[1];\n    this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;\n    this.batchResponseEnding = `--${this.responseBatchBoundary}--`;\n  } // For example of response, please refer to https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#response\n\n\n  parseBatchResponse() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse\n      // sub request's response.\n      if (_this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {\n        throw new Error(`Invalid state: batch request failed with status: '${_this.batchResponse._response.status}'.`);\n      }\n\n      const responseBodyAsText = yield getBodyAsText(_this.batchResponse);\n      const subResponses = responseBodyAsText.split(_this.batchResponseEnding)[0] // string after ending is useless\n      .split(_this.perResponsePrefix).slice(1); // string before first response boundary is useless\n\n      const subResponseCount = subResponses.length; // Defensive coding in case of potential error parsing.\n      // Note: subResponseCount == 1 is special case where sub request is invalid.\n      // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n      // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n\n      if (subResponseCount !== _this.subRequests.size && subResponseCount !== 1) {\n        throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n      }\n\n      const deserializedSubResponses = new Array(subResponseCount);\n      let subResponsesSucceededCount = 0;\n      let subResponsesFailedCount = 0; // Parse sub subResponses.\n\n      for (let index = 0; index < subResponseCount; index++) {\n        const subResponse = subResponses[index];\n        const deserializedSubResponse = {};\n        deserializedSubResponse.headers = new HttpHeaders();\n        const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);\n        let subRespHeaderStartFound = false;\n        let subRespHeaderEndFound = false;\n        let subRespFailed = false;\n        let contentId = NOT_FOUND;\n\n        for (const responseLine of responseLines) {\n          if (!subRespHeaderStartFound) {\n            // Convention line to indicate content ID\n            if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n              contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n            } // Http version line with status code indicates the start of sub request's response.\n            // Example: HTTP/1.1 202 Accepted\n\n\n            if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n              subRespHeaderStartFound = true;\n              const tokens = responseLine.split(SPACE_DELIMITER);\n              deserializedSubResponse.status = parseInt(tokens[1]);\n              deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n            }\n\n            continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *\n          }\n\n          if (responseLine.trim() === \"\") {\n            // Sub response's header start line already found, and the first empty line indicates header end line found.\n            if (!subRespHeaderEndFound) {\n              subRespHeaderEndFound = true;\n            }\n\n            continue; // Skip empty line\n          } // Note: when code reach here, it indicates subRespHeaderStartFound == true\n\n\n          if (!subRespHeaderEndFound) {\n            if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {\n              // Defensive coding to prevent from missing valuable lines.\n              throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);\n            } // Parse headers of sub response.\n\n\n            const tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n            deserializedSubResponse.headers.set(tokens[0], tokens[1]);\n\n            if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n              deserializedSubResponse.errorCode = tokens[1];\n              subRespFailed = true;\n            }\n          } else {\n            // Assemble body of sub response.\n            if (!deserializedSubResponse.bodyAsText) {\n              deserializedSubResponse.bodyAsText = \"\";\n            }\n\n            deserializedSubResponse.bodyAsText += responseLine;\n          }\n        } // Inner for end\n        // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n        // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n        // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n        // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n\n\n        if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < _this.subRequests.size && deserializedSubResponses[contentId] === undefined) {\n          deserializedSubResponse._request = _this.subRequests.get(contentId);\n          deserializedSubResponses[contentId] = deserializedSubResponse;\n        } else {\n          logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);\n        }\n\n        if (subRespFailed) {\n          subResponsesFailedCount++;\n        } else {\n          subResponsesSucceededCount++;\n        }\n      }\n\n      return {\n        subResponses: deserializedSubResponses,\n        subResponsesSucceededCount: subResponsesSucceededCount,\n        subResponsesFailedCount: subResponsesFailedCount\n      };\n    })();\n  }\n\n} //# sourceMappingURL=BatchResponseParser.js.map","map":null,"metadata":{},"sourceType":"module"}