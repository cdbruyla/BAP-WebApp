{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nexport const DEFAULT_CLIENT_RETRY_COUNT = 3; // intervals are in ms\n\nexport const DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nexport const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\nexport const DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\nexport function isNumber(n) {\n  return typeof n === \"number\";\n}\n/**\n * @internal\n * Determines if the operation should be retried.\n *\n * @param retryLimit - Specifies the max number of retries.\n * @param predicate - Initial chekck on whether to retry based on given responses or errors\n * @param retryData -  The retry data.\n * @returns True if the operation qualifies for a retry; false otherwise.\n */\n\nexport function shouldRetry(retryLimit, predicate, retryData, response, error) {\n  if (!predicate(response, error)) {\n    return false;\n  }\n\n  return retryData.retryCount < retryLimit;\n}\n/**\n * @internal\n * Updates the retry data for the next attempt.\n *\n * @param retryOptions - specifies retry interval, and its lower bound and upper bound.\n * @param retryData -  The retry data.\n * @param err - The operation\"s error, if any.\n */\n\nexport function updateRetryData(retryOptions, retryData = {\n  retryCount: 0,\n  retryInterval: 0\n}, err) {\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  } // Adjust retry count\n\n\n  retryData.retryCount++; // Adjust retry interval\n\n  let incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;\n  const boundedRandDelta = retryOptions.retryInterval * 0.8 + Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));\n  incrementDelta *= boundedRandDelta;\n  retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);\n  return retryData;\n} //# sourceMappingURL=exponentialBackoffStrategy.js.map","map":null,"metadata":{},"sourceType":"module"}