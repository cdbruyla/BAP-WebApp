{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as msalBrowser from \"@azure/msal-browser\";\nimport { AuthenticationRequiredError } from \"../../errors\";\nimport { defaultLoggerCallback, msalToPublic, publicToMsal } from \"../utils\";\nimport { MsalBrowser } from \"./msalBrowserCommon\"; // We keep a copy of the redirect hash.\n\nconst redirectHash = self.location.hash;\n/**\n * Uses MSAL Browser 2.X for browser authentication,\n * which uses the [Auth Code Flow](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow).\n * @internal\n */\n\nexport class MSALAuthCode extends MsalBrowser {\n  /**\n   * Sets up an MSAL object based on the given parameters.\n   * MSAL with Auth Code allows sending a previously obtained `authenticationRecord` through the optional parameters,\n   * which is set to be the active account.\n   * @param options - Parameters necessary and otherwise used to create the MSAL object.\n   */\n  constructor(options) {\n    super(options);\n    this.loginHint = options.loginHint;\n    this.msalConfig.cache = {\n      cacheLocation: \"sessionStorage\",\n      storeAuthStateInCookie: true // Set to true to improve the experience on IE11 and Edge.\n\n    };\n    this.msalConfig.system = {\n      loggerOptions: {\n        loggerCallback: defaultLoggerCallback(this.logger, \"Browser\")\n      }\n    }; // Preparing the MSAL application.\n\n    this.app = new msalBrowser.PublicClientApplication(this.msalConfig);\n\n    if (this.account) {\n      this.app.setActiveAccount(publicToMsal(this.account));\n    }\n  }\n  /**\n   * Loads the account based on the result of the authentication.\n   * If no result was received, tries to load the account from the cache.\n   * @param result - Result object received from MSAL.\n   */\n\n\n  handleBrowserResult(result) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        if (result && result.account) {\n          _this.logger.info(`MSAL Browser V2 authentication successful.`);\n\n          _this.app.setActiveAccount(result.account);\n\n          return msalToPublic(_this.clientId, result.account);\n        } // If by this point we happen to have an active account, we should stop trying to parse this.\n\n\n        const activeAccount = yield _this.app.getActiveAccount();\n\n        if (activeAccount) {\n          return msalToPublic(_this.clientId, activeAccount);\n        } // If we don't have an active account, we try to activate it from all the already loaded accounts.\n\n\n        const accounts = _this.app.getAllAccounts();\n\n        if (accounts.length > 1) {\n          // If there's more than one account in memory, we force the user to authenticate again.\n          // At this point we can't identify which account should this credential work with,\n          // since at this point the user won't have provided enough information.\n          // We log a message in case that helps.\n          _this.logger.info(`More than one account was found authenticated for this Client ID and Tenant ID.\nHowever, no \"authenticationRecord\" has been provided for this credential,\ntherefore we're unable to pick between these accounts.\nA new login attempt will be requested, to ensure the correct account is picked.\nTo work with multiple accounts for the same Client ID and Tenant ID, please provide an \"authenticationRecord\" when initializing \"InteractiveBrowserCredential\".`); // To safely trigger a new login, we're also ensuring the local cache is cleared up for this MSAL object.\n          // However, we want to avoid kicking the user out of their authentication on the Azure side.\n          // We do this by calling to logout while specifying a `onRedirectNavigate` that returns false.\n\n\n          yield _this.app.logout({\n            onRedirectNavigate: () => false\n          });\n          return;\n        } // If there's only one account for this MSAL object, we can safely activate it.\n\n\n        if (accounts.length === 1) {\n          const account = accounts[0];\n\n          _this.app.setActiveAccount(account);\n\n          return msalToPublic(_this.clientId, account);\n        }\n\n        _this.logger.info(`No accounts were found through MSAL.`);\n      } catch (e) {\n        _this.logger.info(`Failed to acquire token through MSAL. ${e.message}`);\n      }\n\n      return;\n    })();\n  }\n  /**\n   * Uses MSAL to handle the redirect.\n   */\n\n\n  handleRedirect() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.handleBrowserResult((yield _this2.app.handleRedirectPromise(redirectHash)) || undefined);\n    })();\n  }\n  /**\n   * Uses MSAL to trigger a redirect or a popup login.\n   */\n\n\n  login(scopes = []) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];\n      const loginRequest = {\n        scopes: arrayScopes,\n        loginHint: _this3.loginHint\n      };\n\n      switch (_this3.loginStyle) {\n        case \"redirect\":\n          {\n            yield _this3.app.loginRedirect(loginRequest);\n            return;\n          }\n\n        case \"popup\":\n          return _this3.handleBrowserResult(yield _this3.app.loginPopup(loginRequest));\n      }\n    })();\n  }\n  /**\n   * Uses MSAL to retrieve the active account.\n   */\n\n\n  getActiveAccount() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const account = _this4.app.getActiveAccount();\n\n      if (!account) {\n        return;\n      }\n\n      return msalToPublic(_this4.clientId, account);\n    })();\n  }\n  /**\n   * Attempts to retrieve a token from cache.\n   */\n\n\n  getTokenSilent(scopes, options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const account = yield _this5.getActiveAccount();\n\n      if (!account) {\n        throw new AuthenticationRequiredError({\n          scopes,\n          getTokenOptions: options,\n          message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\"\n        });\n      }\n\n      const parameters = {\n        authority: (options === null || options === void 0 ? void 0 : options.authority) || _this5.msalConfig.auth.authority,\n        correlationId: options === null || options === void 0 ? void 0 : options.correlationId,\n        claims: options === null || options === void 0 ? void 0 : options.claims,\n        account: publicToMsal(account),\n        forceRefresh: false,\n        scopes\n      };\n\n      try {\n        _this5.logger.info(\"Attempting to acquire token silently\");\n\n        const response = yield _this5.app.acquireTokenSilent(parameters);\n        return _this5.handleResult(scopes, _this5.clientId, response);\n      } catch (err) {\n        throw _this5.handleError(scopes, err, options);\n      }\n    })();\n  }\n  /**\n   * Attempts to retrieve the token in the browser.\n   */\n\n\n  doGetToken(scopes, options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const account = yield _this6.getActiveAccount();\n\n      if (!account) {\n        throw new AuthenticationRequiredError({\n          scopes,\n          getTokenOptions: options,\n          message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\"\n        });\n      }\n\n      const parameters = {\n        authority: (options === null || options === void 0 ? void 0 : options.authority) || _this6.msalConfig.auth.authority,\n        correlationId: options === null || options === void 0 ? void 0 : options.correlationId,\n        claims: options === null || options === void 0 ? void 0 : options.claims,\n        account: publicToMsal(account),\n        loginHint: _this6.loginHint,\n        scopes\n      };\n\n      switch (_this6.loginStyle) {\n        case \"redirect\":\n          // This will go out of the page.\n          // Once the InteractiveBrowserCredential is initialized again,\n          // we'll load the MSAL account in the constructor.\n          yield _this6.app.acquireTokenRedirect(parameters);\n          return {\n            token: \"\",\n            expiresOnTimestamp: 0\n          };\n\n        case \"popup\":\n          return _this6.handleResult(scopes, _this6.clientId, yield _this6.app.acquireTokenPopup(parameters));\n      }\n    })();\n  }\n\n} //# sourceMappingURL=msalAuthCode.js.map","map":null,"metadata":{},"sourceType":"module"}