{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_MIN_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, isNumber, shouldRetry, updateRetryData } from \"../util/exponentialBackoffStrategy\";\nimport { delay } from \"../util/delay\";\n/**\n * A policy that retries when there's a system error, identified by the codes \"ETIMEDOUT\", \"ESOCKETTIMEDOUT\", \"ECONNREFUSED\", \"ECONNRESET\" or \"ENOENT\".\n * @param retryCount - Maximum number of retries.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n * @returns An instance of the {@link SystemErrorRetryPolicy}\n */\n\nexport function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n  return {\n    create: (nextPolicy, options) => {\n      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * A policy that retries when there's a system error, identified by the codes \"ETIMEDOUT\", \"ESOCKETTIMEDOUT\", \"ECONNREFUSED\", \"ECONNRESET\" or \"ENOENT\".\n * @param retryCount - The client retry count.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n */\n\nexport class SystemErrorRetryPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  sendRequest(request) {\n    return this._nextPolicy.sendRequest(request.clone()).catch(error => retry(this, request, error.response, error));\n  }\n\n}\n\nfunction retry(_x, _x2, _x3, _x4, _x5) {\n  return _retry.apply(this, arguments);\n} //# sourceMappingURL=systemErrorRetryPolicy.js.map\n\n\nfunction _retry() {\n  _retry = _asyncToGenerator(function* (policy, request, operationResponse, err, retryData) {\n    retryData = updateRetryData(policy, retryData, err);\n\n    function shouldPolicyRetry(_response, error) {\n      if (error && error.code && (error.code === \"ETIMEDOUT\" || error.code === \"ESOCKETTIMEDOUT\" || error.code === \"ECONNREFUSED\" || error.code === \"ECONNRESET\" || error.code === \"ENOENT\")) {\n        return true;\n      }\n\n      return false;\n    }\n\n    if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) {\n      // If previous operation ended with an error and the policy allows a retry, do that\n      try {\n        yield delay(retryData.retryInterval);\n        return policy._nextPolicy.sendRequest(request.clone());\n      } catch (nestedErr) {\n        return retry(policy, request, operationResponse, nestedErr, retryData);\n      }\n    } else {\n      if (err) {\n        // If the operation failed in the end, return all errors instead of just the last one\n        return Promise.reject(retryData.error);\n      }\n\n      return operationResponse;\n    }\n  });\n  return _retry.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}