{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, isNumber, shouldRetry, updateRetryData } from \"../util/exponentialBackoffStrategy\";\nimport { Constants } from \"../util/constants\";\nimport { RestError } from \"../restError\";\nimport { delay } from \"../util/delay\";\nimport { logger } from \"../log\";\n/**\n * Policy that retries the request as many times as configured for as long as the max retry time interval specified, each retry waiting longer to begin than the last time.\n * @param retryCount - Maximum number of retries.\n * @param retryInterval - Base time between retries.\n * @param maxRetryInterval - Maximum time to wait between retries.\n */\n\nexport function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {\n  return {\n    create: (nextPolicy, options) => {\n      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n */\n\nexport var RetryMode = /*#__PURE__*/(() => {\n  (function (RetryMode) {\n    /**\n     * Currently supported retry mode.\n     * Each time a retry happens, it will take exponentially more time than the last time.\n     */\n    RetryMode[RetryMode[\"Exponential\"] = 0] = \"Exponential\";\n  })(RetryMode || (RetryMode = {}));\n\n  return RetryMode;\n})();\nexport const DefaultRetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL\n};\n/**\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\n\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * @param nextPolicy - The next RequestPolicy in the pipeline chain.\n   * @param options - The options for this RequestPolicy.\n   * @param retryCount - The client retry count.\n   * @param retryInterval - The client retry interval, in milliseconds.\n   * @param minRetryInterval - The minimum retry interval, in milliseconds.\n   * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n   */\n  constructor(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  sendRequest(request) {\n    return this._nextPolicy.sendRequest(request.clone()).then(response => retry(this, request, response)).catch(error => retry(this, request, error.response, undefined, error));\n  }\n\n}\n\nfunction retry(_x, _x2, _x3, _x4, _x5) {\n  return _retry.apply(this, arguments);\n} //# sourceMappingURL=exponentialRetryPolicy.js.map\n\n\nfunction _retry() {\n  _retry = _asyncToGenerator(function* (policy, request, response, retryData, requestError) {\n    function shouldPolicyRetry(responseParam) {\n      const statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;\n\n      if (statusCode === 503 && (response === null || response === void 0 ? void 0 : response.headers.get(Constants.HeaderConstants.RETRY_AFTER))) {\n        return false;\n      }\n\n      if (statusCode === undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {\n        return false;\n      }\n\n      return true;\n    }\n\n    retryData = updateRetryData({\n      retryInterval: policy.retryInterval,\n      minRetryInterval: 0,\n      maxRetryInterval: policy.maxRetryInterval\n    }, retryData, requestError);\n    const isAborted = request.abortSignal && request.abortSignal.aborted;\n\n    if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {\n      logger.info(`Retrying request in ${retryData.retryInterval}`);\n\n      try {\n        yield delay(retryData.retryInterval);\n        const res = yield policy._nextPolicy.sendRequest(request.clone());\n        return retry(policy, request, res, retryData);\n      } catch (err) {\n        return retry(policy, request, response, retryData, err);\n      }\n    } else if (isAborted || requestError || !response) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      const err = retryData.error || new RestError(\"Failed to send the request.\", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);\n      throw err;\n    } else {\n      return response;\n    }\n  });\n  return _retry.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}