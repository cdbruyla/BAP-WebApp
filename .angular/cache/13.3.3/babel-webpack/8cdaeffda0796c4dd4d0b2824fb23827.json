{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n/**\n * States for Batch.\n */\n\nvar BatchStates = /*#__PURE__*/(() => {\n  (function (BatchStates) {\n    BatchStates[BatchStates[\"Good\"] = 0] = \"Good\";\n    BatchStates[BatchStates[\"Error\"] = 1] = \"Error\";\n  })(BatchStates || (BatchStates = {}));\n\n  return BatchStates;\n})();\n\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  constructor(concurrency = 5) {\n    /**\n     * Number of active operations under execution.\n     */\n    this.actives = 0;\n    /**\n     * Number of completed operations under execution.\n     */\n\n    this.completed = 0;\n    /**\n     * Offset of next operation to be executed.\n     */\n\n    this.offset = 0;\n    /**\n     * Operation array to be executed.\n     */\n\n    this.operations = [];\n    /**\n     * States of Batch. When an error happens, state will turn into error.\n     * Batch will stop execute left operations.\n     */\n\n    this.state = BatchStates.Good;\n\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n\n\n  addOperation(operation) {\n    var _this = this;\n\n    this.operations.push( /*#__PURE__*/_asyncToGenerator(function* () {\n      try {\n        _this.actives++;\n        yield operation();\n        _this.actives--;\n        _this.completed++;\n\n        _this.parallelExecute();\n      } catch (error) {\n        _this.emitter.emit(\"error\", error);\n      }\n    }));\n  }\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n\n\n  do() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.operations.length === 0) {\n        return Promise.resolve();\n      }\n\n      _this2.parallelExecute();\n\n      return new Promise((resolve, reject) => {\n        _this2.emitter.on(\"finish\", resolve);\n\n        _this2.emitter.on(\"error\", error => {\n          _this2.state = BatchStates.Error;\n          reject(error);\n        });\n      });\n    })();\n  }\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n\n\n  nextOperation() {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n\n    return null;\n  }\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n\n\n  parallelExecute() {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n\n} //# sourceMappingURL=Batch.js.map","map":null,"metadata":{},"sourceType":"module"}