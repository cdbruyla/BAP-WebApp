{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\n\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\n\nexport function retryPolicy(strategies, options = {\n  maxRetries: DEFAULT_RETRY_POLICY_COUNT\n}) {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n\n        let response;\n        let responseError;\n        let retryCount = -1; // eslint-disable-next-line no-constant-condition\n\n        retryRequest: while (true) {\n          retryCount += 1;\n          response = undefined;\n          responseError = undefined;\n\n          try {\n            logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n            response = yield next(request);\n            logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n          } catch (e) {\n            logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId); // RestErrors are valid targets for the retry strategies.\n            // If none of the retry strategies can work with them, they will be thrown later in this policy.\n            // If the received error is not a RestError, it is immediately thrown.\n\n            responseError = e;\n\n            if (!e || responseError.name !== \"RestError\") {\n              throw e;\n            }\n\n            response = responseError.response;\n          }\n\n          if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n            logger.error(`Retry ${retryCount}: Request aborted.`);\n            const abortError = new AbortError();\n            throw abortError;\n          }\n\n          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n            logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n\n            if (responseError) {\n              throw responseError;\n            } else if (response) {\n              return response;\n            } else {\n              throw new Error(\"Maximum retries reached with no response or error to throw\");\n            }\n          }\n\n          logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n\n          strategiesLoop: for (const strategy of strategies) {\n            const strategyLogger = strategy.logger || retryPolicyLogger;\n            strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n            const modifiers = strategy.retry({\n              retryCount,\n              response,\n              responseError\n            });\n\n            if (modifiers.skipStrategy) {\n              strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n              continue strategiesLoop;\n            }\n\n            const {\n              errorToThrow,\n              retryAfterInMs,\n              redirectTo\n            } = modifiers;\n\n            if (errorToThrow) {\n              strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n              throw errorToThrow;\n            }\n\n            if (retryAfterInMs || retryAfterInMs === 0) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n              yield delay(retryAfterInMs, undefined, {\n                abortSignal: request.abortSignal\n              });\n              continue retryRequest;\n            }\n\n            if (redirectTo) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n              request.url = redirectTo;\n              continue retryRequest;\n            }\n          }\n\n          if (responseError) {\n            logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n            throw responseError;\n          }\n\n          if (response) {\n            logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n            return response;\n          } // If all the retries skip and there's no response,\n          // we're still in the retry loop, so a new request will be sent\n          // until `maxRetries` is reached.\n\n        }\n      })();\n    }\n\n  };\n} //# sourceMappingURL=retryPolicy.js.map","map":null,"metadata":{},"sourceType":"module"}