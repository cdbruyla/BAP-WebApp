{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getPollingUrl, inferLroMode, isUnexpectedInitialResponse } from \"./requestUtils\";\nimport { isBodyPollingDone, processBodyPollingOperationResult } from \"./bodyPolling\";\nimport { logger } from \"./logger\";\nimport { processLocationPollingOperationResult } from \"./locationPolling\";\nimport { processPassthroughOperationResult } from \"./passthrough\";\n/**\n * creates a stepping function that maps an LRO state to another.\n */\n\nexport function createGetLroStatusFromResponse(lroPrimitives, config, lroResourceLocationConfig) {\n  switch (config.mode) {\n    case \"Location\":\n      {\n        return processLocationPollingOperationResult(lroPrimitives, config.resourceLocation, lroResourceLocationConfig);\n      }\n\n    case \"Body\":\n      {\n        return processBodyPollingOperationResult;\n      }\n\n    default:\n      {\n        return processPassthroughOperationResult;\n      }\n  }\n}\n/**\n * Creates a polling operation.\n */\n\nexport function createPoll(lroPrimitives) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (path, pollerConfig, getLroStatusFromResponse) {\n      const response = yield lroPrimitives.sendPollRequest(path);\n      const retryAfter = response.rawResponse.headers[\"retry-after\"];\n\n      if (retryAfter !== undefined) {\n        // Retry-After header value is either in HTTP date format, or in seconds\n        const retryAfterInSeconds = parseInt(retryAfter);\n        pollerConfig.intervalInMs = isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter), pollerConfig.intervalInMs) : retryAfterInSeconds * 1000;\n      }\n\n      return getLroStatusFromResponse(response);\n    });\n\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction calculatePollingIntervalFromDate(retryAfterDate, defaultIntervalInMs) {\n  const timeNow = Math.floor(new Date().getTime());\n  const retryAfterTime = retryAfterDate.getTime();\n\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n\n  return defaultIntervalInMs;\n}\n/**\n * Creates a callback to be used to initialize the polling operation state.\n * @param state - of the polling operation\n * @param operationSpec - of the LRO\n * @param callback - callback to be called when the operation is done\n * @returns callback that initializes the state of the polling operation\n */\n\n\nexport function createInitializeState(state, requestPath, requestMethod) {\n  return response => {\n    if (isUnexpectedInitialResponse(response.rawResponse)) return true;\n    state.initialRawResponse = response.rawResponse;\n    state.isStarted = true;\n    state.pollingURL = getPollingUrl(state.initialRawResponse, requestPath);\n    state.config = inferLroMode(requestPath, requestMethod, state.initialRawResponse);\n    /** short circuit polling if body polling is done in the initial request */\n\n    if (state.config.mode === undefined || state.config.mode === \"Body\" && isBodyPollingDone(state.initialRawResponse)) {\n      state.result = response.flatResponse;\n      state.isCompleted = true;\n    }\n\n    logger.verbose(`LRO: initial state: ${JSON.stringify(state)}`);\n    return Boolean(state.isCompleted);\n  };\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/core-lro/dist-esm/src/lroEngine/stateMachine.js"],"names":["getPollingUrl","inferLroMode","isUnexpectedInitialResponse","isBodyPollingDone","processBodyPollingOperationResult","logger","processLocationPollingOperationResult","processPassthroughOperationResult","createGetLroStatusFromResponse","lroPrimitives","config","lroResourceLocationConfig","mode","resourceLocation","createPoll","path","pollerConfig","getLroStatusFromResponse","response","sendPollRequest","retryAfter","rawResponse","headers","undefined","retryAfterInSeconds","parseInt","intervalInMs","isNaN","calculatePollingIntervalFromDate","Date","retryAfterDate","defaultIntervalInMs","timeNow","Math","floor","getTime","retryAfterTime","createInitializeState","state","requestPath","requestMethod","initialRawResponse","isStarted","pollingURL","result","flatResponse","isCompleted","verbose","JSON","stringify","Boolean"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getPollingUrl, inferLroMode, isUnexpectedInitialResponse } from \"./requestUtils\";\nimport { isBodyPollingDone, processBodyPollingOperationResult } from \"./bodyPolling\";\nimport { logger } from \"./logger\";\nimport { processLocationPollingOperationResult } from \"./locationPolling\";\nimport { processPassthroughOperationResult } from \"./passthrough\";\n/**\n * creates a stepping function that maps an LRO state to another.\n */\nexport function createGetLroStatusFromResponse(lroPrimitives, config, lroResourceLocationConfig) {\n    switch (config.mode) {\n        case \"Location\": {\n            return processLocationPollingOperationResult(lroPrimitives, config.resourceLocation, lroResourceLocationConfig);\n        }\n        case \"Body\": {\n            return processBodyPollingOperationResult;\n        }\n        default: {\n            return processPassthroughOperationResult;\n        }\n    }\n}\n/**\n * Creates a polling operation.\n */\nexport function createPoll(lroPrimitives) {\n    return async (path, pollerConfig, getLroStatusFromResponse) => {\n        const response = await lroPrimitives.sendPollRequest(path);\n        const retryAfter = response.rawResponse.headers[\"retry-after\"];\n        if (retryAfter !== undefined) {\n            // Retry-After header value is either in HTTP date format, or in seconds\n            const retryAfterInSeconds = parseInt(retryAfter);\n            pollerConfig.intervalInMs = isNaN(retryAfterInSeconds)\n                ? calculatePollingIntervalFromDate(new Date(retryAfter), pollerConfig.intervalInMs)\n                : retryAfterInSeconds * 1000;\n        }\n        return getLroStatusFromResponse(response);\n    };\n}\nfunction calculatePollingIntervalFromDate(retryAfterDate, defaultIntervalInMs) {\n    const timeNow = Math.floor(new Date().getTime());\n    const retryAfterTime = retryAfterDate.getTime();\n    if (timeNow < retryAfterTime) {\n        return retryAfterTime - timeNow;\n    }\n    return defaultIntervalInMs;\n}\n/**\n * Creates a callback to be used to initialize the polling operation state.\n * @param state - of the polling operation\n * @param operationSpec - of the LRO\n * @param callback - callback to be called when the operation is done\n * @returns callback that initializes the state of the polling operation\n */\nexport function createInitializeState(state, requestPath, requestMethod) {\n    return (response) => {\n        if (isUnexpectedInitialResponse(response.rawResponse))\n            return true;\n        state.initialRawResponse = response.rawResponse;\n        state.isStarted = true;\n        state.pollingURL = getPollingUrl(state.initialRawResponse, requestPath);\n        state.config = inferLroMode(requestPath, requestMethod, state.initialRawResponse);\n        /** short circuit polling if body polling is done in the initial request */\n        if (state.config.mode === undefined ||\n            (state.config.mode === \"Body\" && isBodyPollingDone(state.initialRawResponse))) {\n            state.result = response.flatResponse;\n            state.isCompleted = true;\n        }\n        logger.verbose(`LRO: initial state: ${JSON.stringify(state)}`);\n        return Boolean(state.isCompleted);\n    };\n}\n"]},"metadata":{},"sourceType":"module"}