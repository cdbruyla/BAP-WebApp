{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { createSpan } from \"../util/tracing\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { credentialLogger, formatSuccess, formatError } from \"../util/logging\";\n/**\n * @internal\n */\n\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\n\nexport class ChainedTokenCredential {\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```javascript\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  constructor(...sources) {\n    /**\n     * The message to use when the chained token fails to get a token\n     */\n    this.UnavailableMessage = \"ChainedTokenCredential => failed to retrieve a token from the included credentials\";\n    this._sources = [];\n    this._sources = sources;\n  }\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n\n\n  getToken(scopes, options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let token = null;\n      let successfulCredentialName = \"\";\n      const errors = [];\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ChainedTokenCredential.getToken\", options);\n\n      for (let i = 0; i < _this._sources.length && token === null; i++) {\n        try {\n          token = yield _this._sources[i].getToken(scopes, updatedOptions);\n          successfulCredentialName = _this._sources[i].constructor.name;\n        } catch (err) {\n          if (err.name === \"CredentialUnavailableError\" || err.name === \"AuthenticationRequiredError\") {\n            errors.push(err);\n          } else {\n            logger.getToken.info(formatError(scopes, err));\n            throw err;\n          }\n        }\n      }\n\n      if (!token && errors.length > 0) {\n        const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message\n        });\n        logger.getToken.info(formatError(scopes, err));\n        throw err;\n      }\n\n      span.end();\n      logger.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);\n\n      if (token === null) {\n        throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n      }\n\n      return token;\n    })();\n  }\n\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/identity/dist-esm/src/credentials/chainedTokenCredential.js"],"names":["AggregateAuthenticationError","CredentialUnavailableError","createSpan","SpanStatusCode","credentialLogger","formatSuccess","formatError","logger","ChainedTokenCredential","constructor","sources","UnavailableMessage","_sources","getToken","scopes","options","token","successfulCredentialName","errors","span","updatedOptions","i","length","name","err","push","info","setStatus","code","ERROR","message","end"],"mappings":";AAAA;AACA;AACA,SAASA,4BAAT,EAAuCC,0BAAvC,QAAyE,WAAzE;AACA,SAASC,UAAT,QAA2B,iBAA3B;AACA,SAASC,cAAT,QAA+B,qBAA/B;AACA,SAASC,gBAAT,EAA2BC,aAA3B,EAA0CC,WAA1C,QAA6D,iBAA7D;AACA;AACA;AACA;;AACA,OAAO,MAAMC,MAAM,GAAGH,gBAAgB,CAAC,wBAAD,CAA/B;AACP;AACA;AACA;AACA;;AACA,OAAO,MAAMI,sBAAN,CAA6B;AAChC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAAC,GAAGC,OAAJ,EAAa;AACpB;AACR;AACA;AACQ,SAAKC,kBAAL,GAA0B,oFAA1B;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKA,QAAL,GAAgBF,OAAhB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUG,EAAAA,QAAQ,CAACC,MAAD,EAASC,OAAT,EAAkB;AAAA;;AAAA;AAC5B,UAAIC,KAAK,GAAG,IAAZ;AACA,UAAIC,wBAAwB,GAAG,EAA/B;AACA,YAAMC,MAAM,GAAG,EAAf;AACA,YAAM;AAAEC,QAAAA,IAAF;AAAQC,QAAAA;AAAR,UAA2BlB,UAAU,CAAC,iCAAD,EAAoCa,OAApC,CAA3C;;AACA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAI,CAACT,QAAL,CAAcU,MAAlB,IAA4BN,KAAK,KAAK,IAAtD,EAA4DK,CAAC,EAA7D,EAAiE;AAC7D,YAAI;AACAL,UAAAA,KAAK,SAAS,KAAI,CAACJ,QAAL,CAAcS,CAAd,EAAiBR,QAAjB,CAA0BC,MAA1B,EAAkCM,cAAlC,CAAd;AACAH,UAAAA,wBAAwB,GAAG,KAAI,CAACL,QAAL,CAAcS,CAAd,EAAiBZ,WAAjB,CAA6Bc,IAAxD;AACH,SAHD,CAIA,OAAOC,GAAP,EAAY;AACR,cAAIA,GAAG,CAACD,IAAJ,KAAa,4BAAb,IACAC,GAAG,CAACD,IAAJ,KAAa,6BADjB,EACgD;AAC5CL,YAAAA,MAAM,CAACO,IAAP,CAAYD,GAAZ;AACH,WAHD,MAIK;AACDjB,YAAAA,MAAM,CAACM,QAAP,CAAgBa,IAAhB,CAAqBpB,WAAW,CAACQ,MAAD,EAASU,GAAT,CAAhC;AACA,kBAAMA,GAAN;AACH;AACJ;AACJ;;AACD,UAAI,CAACR,KAAD,IAAUE,MAAM,CAACI,MAAP,GAAgB,CAA9B,EAAiC;AAC7B,cAAME,GAAG,GAAG,IAAIxB,4BAAJ,CAAiCkB,MAAjC,EAAyC,+CAAzC,CAAZ;AACAC,QAAAA,IAAI,CAACQ,SAAL,CAAe;AACXC,UAAAA,IAAI,EAAEzB,cAAc,CAAC0B,KADV;AAEXC,UAAAA,OAAO,EAAEN,GAAG,CAACM;AAFF,SAAf;AAIAvB,QAAAA,MAAM,CAACM,QAAP,CAAgBa,IAAhB,CAAqBpB,WAAW,CAACQ,MAAD,EAASU,GAAT,CAAhC;AACA,cAAMA,GAAN;AACH;;AACDL,MAAAA,IAAI,CAACY,GAAL;AACAxB,MAAAA,MAAM,CAACM,QAAP,CAAgBa,IAAhB,CAAsB,cAAaT,wBAAyB,KAAIZ,aAAa,CAACS,MAAD,CAAS,EAAtF;;AACA,UAAIE,KAAK,KAAK,IAAd,EAAoB;AAChB,cAAM,IAAIf,0BAAJ,CAA+B,kCAA/B,CAAN;AACH;;AACD,aAAOe,KAAP;AAnC4B;AAoC/B;;AAtE+B","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { createSpan } from \"../util/tracing\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { credentialLogger, formatSuccess, formatError } from \"../util/logging\";\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport class ChainedTokenCredential {\n    /**\n     * Creates an instance of ChainedTokenCredential using the given credentials.\n     *\n     * @param sources - `TokenCredential` implementations to be tried in order.\n     *\n     * Example usage:\n     * ```javascript\n     * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n     * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n     * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n     * ```\n     */\n    constructor(...sources) {\n        /**\n         * The message to use when the chained token fails to get a token\n         */\n        this.UnavailableMessage = \"ChainedTokenCredential => failed to retrieve a token from the included credentials\";\n        this._sources = [];\n        this._sources = sources;\n    }\n    /**\n     * Returns the first access token returned by one of the chained\n     * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n     * when one or more credentials throws an {@link AuthenticationError} and\n     * no credentials have returned an access token.\n     *\n     * This method is called automatically by Azure SDK client libraries. You may call this method\n     * directly, but you must also handle token caching and token refreshing.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                `TokenCredential` implementation might make.\n     */\n    async getToken(scopes, options) {\n        let token = null;\n        let successfulCredentialName = \"\";\n        const errors = [];\n        const { span, updatedOptions } = createSpan(\"ChainedTokenCredential.getToken\", options);\n        for (let i = 0; i < this._sources.length && token === null; i++) {\n            try {\n                token = await this._sources[i].getToken(scopes, updatedOptions);\n                successfulCredentialName = this._sources[i].constructor.name;\n            }\n            catch (err) {\n                if (err.name === \"CredentialUnavailableError\" ||\n                    err.name === \"AuthenticationRequiredError\") {\n                    errors.push(err);\n                }\n                else {\n                    logger.getToken.info(formatError(scopes, err));\n                    throw err;\n                }\n            }\n        }\n        if (!token && errors.length > 0) {\n            const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: err.message,\n            });\n            logger.getToken.info(formatError(scopes, err));\n            throw err;\n        }\n        span.end();\n        logger.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);\n        if (token === null) {\n            throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n        }\n        return token;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}