{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createGetLroStatusFromResponse, createInitializeState, createPoll } from \"./stateMachine\";\nimport { getPollingUrl } from \"./requestUtils\";\nimport { logger } from \"./logger\";\nexport class GenericPollOperation {\n  constructor(state, lro, lroResourceLocationConfig, processResult, updateState, isDone) {\n    this.state = state;\n    this.lro = lro;\n    this.lroResourceLocationConfig = lroResourceLocationConfig;\n    this.processResult = processResult;\n    this.updateState = updateState;\n    this.isDone = isDone;\n  }\n\n  setPollerConfig(pollerConfig) {\n    this.pollerConfig = pollerConfig;\n  }\n  /**\n   * General update function for LROPoller, the general process is as follows\n   * 1. Check initial operation result to determine the strategy to use\n   *  - Strategies: Location, Azure-AsyncOperation, Original Uri\n   * 2. Check if the operation result has a terminal state\n   *  - Terminal state will be determined by each strategy\n   *  2.1 If it is terminal state Check if a final GET request is required, if so\n   *      send final GET request and return result from operation. If no final GET\n   *      is required, just return the result from operation.\n   *      - Determining what to call for final request is responsibility of each strategy\n   *  2.2 If it is not terminal state, call the polling operation and go to step 1\n   *      - Determining what to call for polling is responsibility of each strategy\n   *      - Strategies will always use the latest URI for polling if provided otherwise\n   *        the last known one\n   */\n\n\n  update(options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const state = _this.state;\n      let lastResponse = undefined;\n\n      if (!state.isStarted) {\n        const initializeState = createInitializeState(state, _this.lro.requestPath, _this.lro.requestMethod);\n        lastResponse = yield _this.lro.sendInitialRequest();\n        initializeState(lastResponse);\n      }\n\n      if (!state.isCompleted) {\n        if (!_this.poll || !_this.getLroStatusFromResponse) {\n          if (!state.config) {\n            throw new Error(\"Bad state: LRO mode is undefined. Please check if the serialized state is well-formed.\");\n          }\n\n          const isDone = _this.isDone;\n          _this.getLroStatusFromResponse = isDone ? response => Object.assign(Object.assign({}, response), {\n            done: isDone(response.flatResponse, _this.state)\n          }) : createGetLroStatusFromResponse(_this.lro, state.config, _this.lroResourceLocationConfig);\n          _this.poll = createPoll(_this.lro);\n        }\n\n        if (!state.pollingURL) {\n          throw new Error(\"Bad state: polling URL is undefined. Please check if the serialized state is well-formed.\");\n        }\n\n        const currentState = yield _this.poll(state.pollingURL, _this.pollerConfig, _this.getLroStatusFromResponse);\n        logger.verbose(`LRO: polling response: ${JSON.stringify(currentState.rawResponse)}`);\n\n        if (currentState.done) {\n          state.result = _this.processResult ? _this.processResult(currentState.flatResponse, state) : currentState.flatResponse;\n          state.isCompleted = true;\n        } else {\n          _this.poll = (_a = currentState.next) !== null && _a !== void 0 ? _a : _this.poll;\n          state.pollingURL = getPollingUrl(currentState.rawResponse, state.pollingURL);\n        }\n\n        lastResponse = currentState;\n      }\n\n      logger.verbose(`LRO: current state: ${JSON.stringify(state)}`);\n\n      if (lastResponse) {\n        (_b = _this.updateState) === null || _b === void 0 ? void 0 : _b.call(_this, state, lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.rawResponse);\n      } else {\n        logger.error(`LRO: no response was received`);\n      }\n\n      (_c = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _c === void 0 ? void 0 : _c.call(options, state);\n      return _this;\n    })();\n  }\n\n  cancel() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.state.isCancelled = true;\n      return _this2;\n    })();\n  }\n  /**\n   * Serializes the Poller operation.\n   */\n\n\n  toString() {\n    return JSON.stringify({\n      state: this.state\n    });\n  }\n\n} //# sourceMappingURL=operation.js.map","map":null,"metadata":{},"sourceType":"module"}