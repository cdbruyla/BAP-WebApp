{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\n\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Default authorize request handler\n */\n\nfunction defaultAuthorizeRequest(_x) {\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\n\n\nfunction _defaultAuthorizeRequest() {\n  _defaultAuthorizeRequest = _asyncToGenerator(function* (options) {\n    const {\n      scopes,\n      getAccessToken,\n      request\n    } = options;\n    const getTokenOptions = {\n      abortSignal: request.abortSignal,\n      tracingOptions: request.tracingOptions\n    };\n    const accessToken = yield getAccessToken(scopes, getTokenOptions);\n\n    if (accessToken) {\n      options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n  });\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n\nfunction getChallenge(response) {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n\n  return;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\n\n\nexport function bearerTokenAuthenticationPolicy(options) {\n  var _a;\n\n  const {\n    credential,\n    scopes,\n    challengeCallbacks,\n    logger\n  } = options;\n  const callbacks = Object.assign({\n    authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge\n  }, challengeCallbacks); // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n\n  const getAccessToken = credential ? createTokenCycler(credential\n  /* , options */\n  ) : () => Promise.resolve(null);\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (!request.url.toLowerCase().startsWith(\"https://\")) {\n          throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n        }\n\n        yield callbacks.authorizeRequest({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          getAccessToken,\n          logger\n        });\n        let response;\n        let error;\n\n        try {\n          response = yield next(request);\n        } catch (err) {\n          error = err;\n          response = err.response;\n        }\n\n        if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {\n          // processes challenge\n          const shouldSendRequest = yield callbacks.authorizeRequestOnChallenge({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            response,\n            getAccessToken,\n            logger\n          });\n\n          if (shouldSendRequest) {\n            return next(request);\n          }\n        }\n\n        if (error) {\n          throw error;\n        } else {\n          return response;\n        }\n      })();\n    }\n\n  };\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js"],"names":["createTokenCycler","bearerTokenAuthenticationPolicyName","defaultAuthorizeRequest","options","scopes","getAccessToken","request","getTokenOptions","abortSignal","tracingOptions","accessToken","headers","set","token","getChallenge","response","challenge","get","status","bearerTokenAuthenticationPolicy","_a","credential","challengeCallbacks","logger","callbacks","Object","assign","authorizeRequest","authorizeRequestOnChallenge","Promise","resolve","name","sendRequest","next","url","toLowerCase","startsWith","Error","Array","isArray","error","err","shouldSendRequest"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options) {\n    const { scopes, getAccessToken, request } = options;\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n    };\n    const accessToken = await getAccessToken(scopes, getTokenOptions);\n    if (accessToken) {\n        options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (response.status === 401 && challenge) {\n        return challenge;\n    }\n    return;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n    var _a;\n    const { credential, scopes, challengeCallbacks, logger } = options;\n    const callbacks = Object.assign({ authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);\n    // This function encapsulates the entire process of reliably retrieving the token\n    // The options are left out of the public API until there's demand to configure this.\n    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n    // in order to pass through the `options` object.\n    const getAccessToken = credential\n        ? createTokenCycler(credential /* , options */)\n        : () => Promise.resolve(null);\n    return {\n        name: bearerTokenAuthenticationPolicyName,\n        /**\n         * If there's no challenge parameter:\n         * - It will try to retrieve the token using the cache, or the credential's getToken.\n         * - Then it will try the next policy with or without the retrieved token.\n         *\n         * It uses the challenge parameters to:\n         * - Skip a first attempt to get the token from the credential if there's no cached token,\n         *   since it expects the token to be retrievable only after the challenge.\n         * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n         * - Send an initial request to receive the challenge if it fails.\n         * - Process a challenge if the response contains it.\n         * - Retrieve a token with the challenge information, then re-send the request.\n         */\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            await callbacks.authorizeRequest({\n                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                request,\n                getAccessToken,\n                logger,\n            });\n            let response;\n            let error;\n            try {\n                response = await next(request);\n            }\n            catch (err) {\n                error = err;\n                response = err.response;\n            }\n            if (callbacks.authorizeRequestOnChallenge &&\n                (response === null || response === void 0 ? void 0 : response.status) === 401 &&\n                getChallenge(response)) {\n                // processes challenge\n                const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n                    scopes: Array.isArray(scopes) ? scopes : [scopes],\n                    request,\n                    response,\n                    getAccessToken,\n                    logger,\n                });\n                if (shouldSendRequest) {\n                    return next(request);\n                }\n            }\n            if (error) {\n                throw error;\n            }\n            else {\n                return response;\n            }\n        },\n    };\n}\n"]},"metadata":{},"sourceType":"module"}