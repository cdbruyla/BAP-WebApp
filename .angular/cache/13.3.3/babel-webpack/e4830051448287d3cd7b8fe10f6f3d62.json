{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { GenericPollOperation } from \"./operation\";\nimport { Poller } from \"../poller\";\n\nfunction deserializeState(serializedState) {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`LroEngine: Unable to deserialize state: ${serializedState}`);\n  }\n}\n/**\n * The LRO Engine, a class that performs polling.\n */\n\n\nexport class LroEngine extends Poller {\n  constructor(lro, options) {\n    const {\n      intervalInMs = 2000,\n      resumeFrom\n    } = options || {};\n    const state = resumeFrom ? deserializeState(resumeFrom) : {};\n    const operation = new GenericPollOperation(state, lro, options === null || options === void 0 ? void 0 : options.lroResourceLocationConfig, options === null || options === void 0 ? void 0 : options.processResult, options === null || options === void 0 ? void 0 : options.updateState, options === null || options === void 0 ? void 0 : options.isDone);\n    super(operation);\n    this.config = {\n      intervalInMs: intervalInMs\n    };\n    operation.setPollerConfig(this.config);\n  }\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   */\n\n\n  delay() {\n    return new Promise(resolve => setTimeout(() => resolve(), this.config.intervalInMs));\n  }\n\n} //# sourceMappingURL=lroEngine.js.map","map":null,"metadata":{},"sourceType":"module"}