{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces\";\nimport { getOperationArgumentValueFromParameter, getOperationRequestInfo } from \"./operationHelpers\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\n/**\n * The programmatic identifier of the serializationPolicy.\n */\n\nexport const serializationPolicyName = \"serializationPolicy\";\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\n\nexport function serializationPolicy(options = {}) {\n  const stringifyXML = options.stringifyXML;\n  return {\n    name: serializationPolicyName,\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        const operationInfo = getOperationRequestInfo(request);\n        const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n        const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;\n\n        if (operationSpec && operationArguments) {\n          serializeHeaders(request, operationArguments, operationSpec);\n          serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n        }\n\n        return next(request);\n      })();\n    }\n\n  };\n}\n/**\n * @internal\n */\n\nexport function serializeHeaders(request, operationArguments, operationSpec) {\n  var _a, _b;\n\n  if (operationSpec.headerParameters) {\n    for (const headerParameter of operationSpec.headerParameters) {\n      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n\n      if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {\n        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n\n        if (headerCollectionPrefix) {\n          for (const key of Object.keys(headerValue)) {\n            request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n          }\n        } else {\n          request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n        }\n      }\n    }\n  }\n\n  const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;\n\n  if (customHeaders) {\n    for (const customHeaderName of Object.keys(customHeaders)) {\n      request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n    }\n  }\n}\n/**\n * @internal\n */\n\nexport function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {\n  throw new Error(\"XML serialization unsupported!\");\n}) {\n  var _a, _b, _c, _d, _e;\n\n  const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  const updatedOptions = {\n    xml: {\n      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : \"\",\n      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,\n      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY\n    }\n  };\n  const xmlCharKey = updatedOptions.xml.xmlCharKey;\n\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      serializedName,\n      xmlName,\n      xmlElementName,\n      xmlNamespace,\n      xmlNamespacePrefix,\n      nullable\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {\n        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);\n        const isStream = typeName === MapperTypeNames.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);\n\n          if (typeName === MapperTypeNames.Sequence) {\n            request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          } else if (!isStream) {\n            request.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          }\n        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          request.body = JSON.stringify(request.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    request.formData = {};\n\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);\n\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n      }\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\n\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: xmlNamespace\n    };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n\n  if (!xmlNamespaceKey || !xmlNamespace) {\n    return {\n      [elementName]: obj\n    };\n  }\n\n  const result = {\n    [elementName]: obj\n  };\n  result[XML_ATTRKEY] = {\n    [xmlNamespaceKey]: xmlNamespace\n  };\n  return result;\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js"],"names":["XML_ATTRKEY","XML_CHARKEY","getOperationArgumentValueFromParameter","getOperationRequestInfo","MapperTypeNames","getPathStringFromParameter","serializationPolicyName","serializationPolicy","options","stringifyXML","name","sendRequest","request","next","operationInfo","operationSpec","operationArguments","serializeHeaders","serializeRequestBody","_a","_b","headerParameters","headerParameter","headerValue","undefined","mapper","required","serializer","serialize","headerCollectionPrefix","key","Object","keys","headers","set","serializedName","customHeaders","requestOptions","customHeaderName","Error","_c","_d","_e","serializerOptions","updatedOptions","xml","rootName","includeRoot","xmlCharKey","requestBody","body","bodyMapper","xmlName","xmlElementName","xmlNamespace","xmlNamespacePrefix","nullable","typeName","type","requestBodyParameterPathString","isStream","Stream","isXML","xmlnsKey","value","getXmlValueWithNamespace","Sequence","prepareXMLRootList","String","contentType","match","mediaType","JSON","stringify","error","message","formDataParameters","length","formData","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializedValue","includes","result","obj","elementName","xmlNamespaceKey","Array","isArray"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_ATTRKEY, XML_CHARKEY, } from \"./interfaces\";\nimport { getOperationArgumentValueFromParameter, getOperationRequestInfo, } from \"./operationHelpers\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options = {}) {\n    const stringifyXML = options.stringifyXML;\n    return {\n        name: serializationPolicyName,\n        async sendRequest(request, next) {\n            const operationInfo = getOperationRequestInfo(request);\n            const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n            const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;\n            if (operationSpec && operationArguments) {\n                serializeHeaders(request, operationArguments, operationSpec);\n                serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n            }\n            return next(request);\n        },\n    };\n}\n/**\n * @internal\n */\nexport function serializeHeaders(request, operationArguments, operationSpec) {\n    var _a, _b;\n    if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n            let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n            if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {\n                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n                const headerCollectionPrefix = headerParameter.mapper\n                    .headerCollectionPrefix;\n                if (headerCollectionPrefix) {\n                    for (const key of Object.keys(headerValue)) {\n                        request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                    }\n                }\n                else {\n                    request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n                }\n            }\n        }\n    }\n    const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;\n    if (customHeaders) {\n        for (const customHeaderName of Object.keys(customHeaders)) {\n            request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n        }\n    }\n}\n/**\n * @internal\n */\nexport function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {\n    throw new Error(\"XML serialization unsupported!\");\n}) {\n    var _a, _b, _c, _d, _e;\n    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n    const updatedOptions = {\n        xml: {\n            rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : \"\",\n            includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,\n            xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY,\n        },\n    };\n    const xmlCharKey = updatedOptions.xml.xmlCharKey;\n    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n        request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);\n        const bodyMapper = operationSpec.requestBody.mapper;\n        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable, } = bodyMapper;\n        const typeName = bodyMapper.type.name;\n        try {\n            if ((request.body !== undefined && request.body !== null) ||\n                (nullable && request.body === null) ||\n                required) {\n                const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n                request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);\n                const isStream = typeName === MapperTypeNames.Stream;\n                if (operationSpec.isXML) {\n                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n                    const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);\n                    if (typeName === MapperTypeNames.Sequence) {\n                        request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });\n                    }\n                    else if (!isStream) {\n                        request.body = stringifyXML(value, {\n                            rootName: xmlName || serializedName,\n                            xmlCharKey,\n                        });\n                    }\n                }\n                else if (typeName === MapperTypeNames.String &&\n                    (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n                    // the String serializer has validated that request body is a string\n                    // so just send the string.\n                    return;\n                }\n                else if (!isStream) {\n                    request.body = JSON.stringify(request.body);\n                }\n            }\n        }\n        catch (error) {\n            throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n        }\n    }\n    else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n        request.formData = {};\n        for (const formDataParameter of operationSpec.formDataParameters) {\n            const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);\n            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n                request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n            }\n        }\n    }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n    // Composite and Sequence schemas already got their root namespace set during serialization\n    // We just need to add xmlns to the other schema types\n    if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n        const result = {};\n        result[options.xml.xmlCharKey] = serializedValue;\n        result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n        return result;\n    }\n    return serializedValue;\n}\nfunction prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n    if (!Array.isArray(obj)) {\n        obj = [obj];\n    }\n    if (!xmlNamespaceKey || !xmlNamespace) {\n        return { [elementName]: obj };\n    }\n    const result = { [elementName]: obj };\n    result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}