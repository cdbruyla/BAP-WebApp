{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline\";\nimport { flattenResponse } from \"./utils\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nimport { getRequestUrl } from \"./urlHelpers\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\n\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param credential - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options = {}) {\n    var _a;\n\n    this._requestContentType = options.requestContentType;\n    this._baseUri = options.baseUri;\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n\n    if ((_a = options.additionalPolicies) === null || _a === void 0 ? void 0 : _a.length) {\n      for (const {\n        policy,\n        position\n      } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase\n        });\n      }\n    }\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n\n\n  sendRequest(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.pipeline.sendRequest(_this._httpClient, request);\n    })();\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n\n\n  sendOperationRequest(operationArguments, operationSpec) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const baseUri = operationSpec.baseUrl || _this2._baseUri;\n\n      if (!baseUri) {\n        throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n      } // Templatized URLs sometimes reference properties on the ServiceClient child class,\n      // so we have to pass `this` below in order to search these properties if they're\n      // not part of OperationArguments\n\n\n      const url = getRequestUrl(baseUri, operationSpec, operationArguments, _this2);\n      const request = createPipelineRequest({\n        url\n      });\n      request.method = operationSpec.httpMethod;\n      const operationInfo = getOperationRequestInfo(request);\n      operationInfo.operationSpec = operationSpec;\n      operationInfo.operationArguments = operationArguments;\n      const contentType = operationSpec.contentType || _this2._requestContentType;\n\n      if (contentType && operationSpec.requestBody) {\n        request.headers.set(\"Content-Type\", contentType);\n      }\n\n      const options = operationArguments.options;\n\n      if (options) {\n        const requestOptions = options.requestOptions;\n\n        if (requestOptions) {\n          if (requestOptions.timeout) {\n            request.timeout = requestOptions.timeout;\n          }\n\n          if (requestOptions.onUploadProgress) {\n            request.onUploadProgress = requestOptions.onUploadProgress;\n          }\n\n          if (requestOptions.onDownloadProgress) {\n            request.onDownloadProgress = requestOptions.onDownloadProgress;\n          }\n\n          if (requestOptions.shouldDeserialize !== undefined) {\n            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n          }\n\n          if (requestOptions.allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n          }\n        }\n\n        if (options.abortSignal) {\n          request.abortSignal = options.abortSignal;\n        }\n\n        if (options.tracingOptions) {\n          request.tracingOptions = options.tracingOptions;\n        }\n      }\n\n      if (_this2._allowInsecureConnection) {\n        request.allowInsecureConnection = true;\n      }\n\n      if (request.streamResponseStatusCodes === undefined) {\n        request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n      }\n\n      try {\n        const rawResponse = yield _this2.sendRequest(request);\n        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n\n        if (options === null || options === void 0 ? void 0 : options.onResponse) {\n          options.onResponse(rawResponse, flatResponse);\n        }\n\n        return flatResponse;\n      } catch (error) {\n        if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n          const rawResponse = error.response;\n          const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n          error.details = flatResponse;\n\n          if (options === null || options === void 0 ? void 0 : options.onResponse) {\n            options.onResponse(rawResponse, flatResponse, error);\n          }\n        }\n\n        throw error;\n      }\n    })();\n  }\n\n}\n\nfunction createDefaultPipeline(options) {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions = options.credential && credentialScopes ? {\n    credentialScopes,\n    credential: options.credential\n  } : undefined;\n  return createClientPipeline(Object.assign(Object.assign({}, options), {\n    credentialOptions\n  }));\n}\n\nfunction getCredentialScopes(options) {\n  if (options.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes) ? scopes.map(scope => new URL(scope).toString()) : new URL(scopes).toString();\n  }\n\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(`When using credentials, the ServiceClientOptions must contain either a baseUri or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n  }\n\n  return undefined;\n} //# sourceMappingURL=serviceClient.js.map","map":null,"metadata":{},"sourceType":"module"}