{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_CHARKEY } from \"./interfaces\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\n\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\n\nexport function deserializationPolicy(options = {}) {\n  var _a, _b, _c, _d, _e, _f, _g;\n\n  const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n  const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n  const parseXML = options.parseXML;\n  const serializerOptions = options.serializerOptions;\n  const updatedOptions = {\n    xml: {\n      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY\n    }\n  };\n  return {\n    name: deserializationPolicyName,\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        const response = yield next(request);\n        return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n      })();\n    }\n\n  };\n}\n\nfunction getOperationResponseMap(parsedResponse) {\n  let result;\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n\n  if (operationSpec) {\n    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n\n  return result;\n}\n\nfunction shouldDeserializeResponse(parsedResponse) {\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n  let result;\n\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n\n  return result;\n}\n\nfunction deserializeResponseBody(_x, _x2, _x3, _x4, _x5) {\n  return _deserializeResponseBody.apply(this, arguments);\n}\n\nfunction _deserializeResponseBody() {\n  _deserializeResponseBody = _asyncToGenerator(function* (jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    const parsedResponse = yield parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n\n    if (!shouldDeserializeResponse(parsedResponse)) {\n      return parsedResponse;\n    }\n\n    const operationInfo = getOperationRequestInfo(parsedResponse.request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n\n    if (!operationSpec || !operationSpec.responses) {\n      return parsedResponse;\n    }\n\n    const responseSpec = getOperationResponseMap(parsedResponse);\n    const {\n      error,\n      shouldReturnResponse\n    } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);\n\n    if (error) {\n      throw error;\n    } else if (shouldReturnResponse) {\n      return parsedResponse;\n    } // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n\n\n    if (responseSpec) {\n      if (responseSpec.bodyMapper) {\n        let valueToDeserialize = parsedResponse.parsedBody;\n\n        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = typeof valueToDeserialize === \"object\" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];\n        }\n\n        try {\n          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\");\n        } catch (deserializeError) {\n          const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {\n            statusCode: parsedResponse.status,\n            request: parsedResponse.request,\n            response: parsedResponse\n          });\n          throw restError;\n        }\n      } else if (operationSpec.httpMethod === \"HEAD\") {\n        // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n      }\n\n      if (responseSpec.headersMapper) {\n        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n      }\n    }\n\n    return parsedResponse;\n  });\n  return _deserializeResponseBody.apply(this, arguments);\n}\n\nfunction isOperationSpecEmpty(operationSpec) {\n  const expectedStatusCodes = Object.keys(operationSpec.responses);\n  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\";\n}\n\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec) {\n  var _a;\n\n  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;\n\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return {\n          error: null,\n          shouldReturnResponse: false\n        };\n      }\n    } else {\n      return {\n        error: null,\n        shouldReturnResponse: false\n      };\n    }\n  }\n\n  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n  const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;\n  const error = new RestError(initialErrorMessage, {\n    statusCode: parsedResponse.status,\n    request: parsedResponse.request,\n    response: parsedResponse\n  }); // If the item failed but there's no error spec or default spec to deserialize the error,\n  // we should fail so we just throw the parsed response\n\n  if (!errorResponseSpec) {\n    throw error;\n  }\n\n  const defaultBodyMapper = errorResponseSpec.bodyMapper;\n  const defaultHeadersMapper = errorResponseSpec.headersMapper;\n\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      const parsedBody = parsedResponse.parsedBody;\n      let deserializedError;\n\n      if (defaultBodyMapper) {\n        let valueToDeserialize = parsedBody;\n\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = [];\n          const elementName = defaultBodyMapper.xmlElementName;\n\n          if (typeof parsedBody === \"object\" && elementName) {\n            valueToDeserialize = parsedBody[elementName];\n          }\n        }\n\n        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\");\n      }\n\n      const internalError = parsedBody.error || deserializedError || parsedBody;\n      error.code = internalError.code;\n\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n\n      if (defaultBodyMapper) {\n        error.response.parsedBody = deserializedError;\n      }\n    } // If error response has headers, try to deserialize it using default header mapper\n\n\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n    }\n  } catch (defaultError) {\n    error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n  }\n\n  return {\n    error,\n    shouldReturnResponse: false\n  };\n}\n\nfunction parse(_x6, _x7, _x8, _x9, _x10) {\n  return _parse.apply(this, arguments);\n}\n\nfunction _parse() {\n  _parse = _asyncToGenerator(function* (jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a;\n\n    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) && operationResponse.bodyAsText) {\n      const text = operationResponse.bodyAsText;\n      const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n      const contentComponents = !contentType ? [] : contentType.split(\";\").map(component => component.toLowerCase());\n\n      try {\n        if (contentComponents.length === 0 || contentComponents.some(component => jsonContentTypes.indexOf(component) !== -1)) {\n          operationResponse.parsedBody = JSON.parse(text);\n          return operationResponse;\n        } else if (contentComponents.some(component => xmlContentTypes.indexOf(component) !== -1)) {\n          if (!parseXML) {\n            throw new Error(\"Parsing XML not supported.\");\n          }\n\n          const body = yield parseXML(text, opts.xml);\n          operationResponse.parsedBody = body;\n          return operationResponse;\n        }\n      } catch (err) {\n        const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n        const errCode = err.code || RestError.PARSE_ERROR;\n        const e = new RestError(msg, {\n          code: errCode,\n          statusCode: operationResponse.status,\n          request: operationResponse.request,\n          response: operationResponse\n        });\n        throw e;\n      }\n    }\n\n    return operationResponse;\n  });\n  return _parse.apply(this, arguments);\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js"],"names":["XML_CHARKEY","RestError","MapperTypeNames","getOperationRequestInfo","defaultJsonContentTypes","defaultXmlContentTypes","deserializationPolicyName","deserializationPolicy","options","_a","_b","_c","_d","_e","_f","_g","jsonContentTypes","expectedContentTypes","json","xmlContentTypes","xml","parseXML","serializerOptions","updatedOptions","rootName","includeRoot","xmlCharKey","name","sendRequest","request","next","response","deserializeResponseBody","getOperationResponseMap","parsedResponse","result","operationInfo","operationSpec","operationResponseGetter","responses","status","shouldDeserializeResponse","shouldDeserialize","undefined","parse","responseSpec","error","shouldReturnResponse","handleErrorResponse","bodyMapper","valueToDeserialize","parsedBody","isXML","type","Sequence","xmlElementName","serializer","deserialize","deserializeError","restError","bodyAsText","statusCode","httpMethod","headersMapper","parsedHeaders","headers","toJSON","isOperationSpecEmpty","expectedStatusCodes","Object","keys","length","isSuccessByStatus","isExpectedStatusCode","isError","errorResponseSpec","default","initialErrorMessage","streamResponseStatusCodes","has","defaultBodyMapper","defaultHeadersMapper","deserializedError","elementName","internalError","code","message","defaultError","operationResponse","opts","text","contentType","get","contentComponents","split","map","component","toLowerCase","some","indexOf","JSON","Error","body","err","msg","errCode","PARSE_ERROR","e"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_CHARKEY, } from \"./interfaces\";\nimport { RestError, } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options = {}) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n    const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n    const parseXML = options.parseXML;\n    const serializerOptions = options.serializerOptions;\n    const updatedOptions = {\n        xml: {\n            rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n            includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n            xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY,\n        },\n    };\n    return {\n        name: deserializationPolicyName,\n        async sendRequest(request, next) {\n            const response = await next(request);\n            return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n        },\n    };\n}\nfunction getOperationResponseMap(parsedResponse) {\n    let result;\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (operationSpec) {\n        if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n            result = operationSpec.responses[parsedResponse.status];\n        }\n        else {\n            result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n        }\n    }\n    return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n    let result;\n    if (shouldDeserialize === undefined) {\n        result = true;\n    }\n    else if (typeof shouldDeserialize === \"boolean\") {\n        result = shouldDeserialize;\n    }\n    else {\n        result = shouldDeserialize(parsedResponse);\n    }\n    return result;\n}\nasync function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n    if (!shouldDeserializeResponse(parsedResponse)) {\n        return parsedResponse;\n    }\n    const operationInfo = getOperationRequestInfo(parsedResponse.request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (!operationSpec || !operationSpec.responses) {\n        return parsedResponse;\n    }\n    const responseSpec = getOperationResponseMap(parsedResponse);\n    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);\n    if (error) {\n        throw error;\n    }\n    else if (shouldReturnResponse) {\n        return parsedResponse;\n    }\n    // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n    if (responseSpec) {\n        if (responseSpec.bodyMapper) {\n            let valueToDeserialize = parsedResponse.parsedBody;\n            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n                valueToDeserialize =\n                    typeof valueToDeserialize === \"object\"\n                        ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]\n                        : [];\n            }\n            try {\n                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\");\n            }\n            catch (deserializeError) {\n                const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {\n                    statusCode: parsedResponse.status,\n                    request: parsedResponse.request,\n                    response: parsedResponse,\n                });\n                throw restError;\n            }\n        }\n        else if (operationSpec.httpMethod === \"HEAD\") {\n            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n        }\n        if (responseSpec.headersMapper) {\n            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n        }\n    }\n    return parsedResponse;\n}\nfunction isOperationSpecEmpty(operationSpec) {\n    const expectedStatusCodes = Object.keys(operationSpec.responses);\n    return (expectedStatusCodes.length === 0 ||\n        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\"));\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec) {\n    var _a;\n    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)\n        ? isSuccessByStatus\n        : !!responseSpec;\n    if (isExpectedStatusCode) {\n        if (responseSpec) {\n            if (!responseSpec.isError) {\n                return { error: null, shouldReturnResponse: false };\n            }\n        }\n        else {\n            return { error: null, shouldReturnResponse: false };\n        }\n    }\n    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status))\n        ? `Unexpected status code: ${parsedResponse.status}`\n        : parsedResponse.bodyAsText;\n    const error = new RestError(initialErrorMessage, {\n        statusCode: parsedResponse.status,\n        request: parsedResponse.request,\n        response: parsedResponse,\n    });\n    // If the item failed but there's no error spec or default spec to deserialize the error,\n    // we should fail so we just throw the parsed response\n    if (!errorResponseSpec) {\n        throw error;\n    }\n    const defaultBodyMapper = errorResponseSpec.bodyMapper;\n    const defaultHeadersMapper = errorResponseSpec.headersMapper;\n    try {\n        // If error response has a body, try to deserialize it using default body mapper.\n        // Then try to extract error code & message from it\n        if (parsedResponse.parsedBody) {\n            const parsedBody = parsedResponse.parsedBody;\n            let deserializedError;\n            if (defaultBodyMapper) {\n                let valueToDeserialize = parsedBody;\n                if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n                    valueToDeserialize = [];\n                    const elementName = defaultBodyMapper.xmlElementName;\n                    if (typeof parsedBody === \"object\" && elementName) {\n                        valueToDeserialize = parsedBody[elementName];\n                    }\n                }\n                deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\");\n            }\n            const internalError = parsedBody.error || deserializedError || parsedBody;\n            error.code = internalError.code;\n            if (internalError.message) {\n                error.message = internalError.message;\n            }\n            if (defaultBodyMapper) {\n                error.response.parsedBody = deserializedError;\n            }\n        }\n        // If error response has headers, try to deserialize it using default header mapper\n        if (parsedResponse.headers && defaultHeadersMapper) {\n            error.response.parsedHeaders =\n                operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n        }\n    }\n    catch (defaultError) {\n        error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n    }\n    return { error, shouldReturnResponse: false };\n}\nasync function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a;\n    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) &&\n        operationResponse.bodyAsText) {\n        const text = operationResponse.bodyAsText;\n        const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n        const contentComponents = !contentType\n            ? []\n            : contentType.split(\";\").map((component) => component.toLowerCase());\n        try {\n            if (contentComponents.length === 0 ||\n                contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {\n                operationResponse.parsedBody = JSON.parse(text);\n                return operationResponse;\n            }\n            else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n                if (!parseXML) {\n                    throw new Error(\"Parsing XML not supported.\");\n                }\n                const body = await parseXML(text, opts.xml);\n                operationResponse.parsedBody = body;\n                return operationResponse;\n            }\n        }\n        catch (err) {\n            const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n            const errCode = err.code || RestError.PARSE_ERROR;\n            const e = new RestError(msg, {\n                code: errCode,\n                statusCode: operationResponse.status,\n                request: operationResponse.request,\n                response: operationResponse,\n            });\n            throw e;\n        }\n    }\n    return operationResponse;\n}\n"]},"metadata":{},"sourceType":"module"}