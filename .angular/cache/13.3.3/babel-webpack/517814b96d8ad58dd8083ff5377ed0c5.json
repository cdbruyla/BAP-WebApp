{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost } from \"../constants\";\nimport { createSpan } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\n\nexport function getIdentityClientAuthorityHost(options) {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost; // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n\n  if (isNode) {\n    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n  } // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n\n\n  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\n\nexport class IdentityClient extends ServiceClient {\n  constructor(options) {\n    var _a;\n\n    const packageDetails = `azsdk-js-identity/2.0.4`;\n    const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;\n    const baseUri = getIdentityClientAuthorityHost(options);\n\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n\n    super(Object.assign(Object.assign({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3\n      }\n    }, options), {\n      userAgentOptions: {\n        userAgentPrefix\n      },\n      baseUri\n    }));\n    this.authorityHost = baseUri;\n    this.abortControllers = new Map();\n  }\n\n  sendTokenRequest(request, expiresOnParser) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      logger.info(`IdentityClient: sending token request to [${request.url}]`);\n      const response = yield _this.sendRequest(request);\n\n      expiresOnParser = expiresOnParser || (responseBody => {\n        return Date.now() + responseBody.expires_in * 1000;\n      });\n\n      if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n        const parsedBody = JSON.parse(response.bodyAsText);\n\n        if (!parsedBody.access_token) {\n          return null;\n        }\n\n        const token = {\n          accessToken: {\n            token: parsedBody.access_token,\n            expiresOnTimestamp: expiresOnParser(parsedBody)\n          },\n          refreshToken: parsedBody.refresh_token\n        };\n        logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n        return token;\n      } else {\n        const error = new AuthenticationError(response.status, response.bodyAsText);\n        logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n        throw error;\n      }\n    })();\n  }\n\n  refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (refreshToken === undefined) {\n        return null;\n      }\n\n      logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"IdentityClient-refreshAccessToken\", options);\n      const refreshParams = {\n        grant_type: \"refresh_token\",\n        client_id: clientId,\n        refresh_token: refreshToken,\n        scope: scopes\n      };\n\n      if (clientSecret !== undefined) {\n        refreshParams.client_secret = clientSecret;\n      }\n\n      const query = new URLSearchParams(refreshParams);\n\n      try {\n        const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n        const request = createPipelineRequest({\n          url: `${_this2.authorityHost}/${tenantId}/${urlSuffix}`,\n          method: \"POST\",\n          body: query.toString(),\n          abortSignal: options && options.abortSignal,\n          headers: createHttpHeaders({\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n          }),\n          tracingOptions: updatedOptions === null || updatedOptions === void 0 ? void 0 : updatedOptions.tracingOptions\n        });\n        const response = yield _this2.sendTokenRequest(request, expiresOnParser);\n        logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n        return response;\n      } catch (err) {\n        if (err.name === AuthenticationErrorName && err.errorResponse.error === \"interaction_required\") {\n          // It's likely that the refresh token has expired, so\n          // return null so that the credential implementation will\n          // initiate the authentication flow again.\n          logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: err.message\n          });\n          return null;\n        } else {\n          logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: err.message\n          });\n          throw err;\n        }\n      } finally {\n        span.end();\n      }\n    })();\n  } // Here is a custom layer that allows us to abort requests that go through MSAL,\n  // since MSAL doesn't allow us to pass options all the way through.\n\n\n  generateAbortSignal(correlationId) {\n    const controller = new AbortController();\n    const controllers = this.abortControllers.get(correlationId) || [];\n    controllers.push(controller);\n    this.abortControllers.set(correlationId, controllers);\n    const existingOnAbort = controller.signal.onabort;\n\n    controller.signal.onabort = (...params) => {\n      this.abortControllers.set(correlationId, undefined);\n\n      if (existingOnAbort) {\n        existingOnAbort(...params);\n      }\n    };\n\n    return controller.signal;\n  }\n\n  abortRequests(correlationId) {\n    const key = correlationId || noCorrelationId;\n    const controllers = [...(this.abortControllers.get(key) || []), // MSAL passes no correlation ID to the get requests...\n    ...(this.abortControllers.get(noCorrelationId) || [])];\n\n    if (!controllers.length) {\n      return;\n    }\n\n    for (const controller of controllers) {\n      controller.abort();\n    }\n\n    this.abortControllers.set(key, undefined);\n  }\n\n  getCorrelationId(options) {\n    var _a;\n\n    const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map(part => part.split(\"=\")).find(([key]) => key === \"client-request-id\");\n    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n  } // The MSAL network module methods follow\n\n\n  sendGetRequestAsync(url, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const request = createPipelineRequest({\n        url,\n        method: \"GET\",\n        body: options === null || options === void 0 ? void 0 : options.body,\n        headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n        abortSignal: _this3.generateAbortSignal(noCorrelationId)\n      });\n      const response = yield _this3.sendRequest(request);\n      return {\n        body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n        headers: response.headers.toJSON(),\n        status: response.status\n      };\n    })();\n  }\n\n  sendPostRequestAsync(url, options) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const request = createPipelineRequest({\n        url,\n        method: \"POST\",\n        body: options === null || options === void 0 ? void 0 : options.body,\n        headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n        // MSAL doesn't send the correlation ID on the get requests.\n        abortSignal: _this4.generateAbortSignal(_this4.getCorrelationId(options))\n      });\n      const response = yield _this4.sendRequest(request);\n      return {\n        body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n        headers: response.headers.toJSON(),\n        status: response.status\n      };\n    })();\n  }\n\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/identity/dist-esm/src/client/identityClient.js"],"names":["SpanStatusCode","ServiceClient","isNode","createHttpHeaders","createPipelineRequest","AbortController","AuthenticationError","AuthenticationErrorName","getIdentityTokenEndpointSuffix","DefaultAuthorityHost","createSpan","logger","noCorrelationId","getIdentityClientAuthorityHost","options","authorityHost","process","env","AZURE_AUTHORITY_HOST","IdentityClient","constructor","_a","packageDetails","userAgentPrefix","userAgentOptions","baseUri","startsWith","Error","Object","assign","requestContentType","retryOptions","maxRetries","abortControllers","Map","sendTokenRequest","request","expiresOnParser","info","url","response","sendRequest","responseBody","Date","now","expires_in","bodyAsText","status","parsedBody","JSON","parse","access_token","token","accessToken","expiresOnTimestamp","refreshToken","refresh_token","error","warning","errorResponse","errorDescription","refreshAccessToken","tenantId","clientId","scopes","clientSecret","undefined","span","updatedOptions","refreshParams","grant_type","client_id","scope","client_secret","query","URLSearchParams","urlSuffix","method","body","toString","abortSignal","headers","Accept","tracingOptions","err","name","setStatus","code","ERROR","message","end","generateAbortSignal","correlationId","controller","controllers","get","push","set","existingOnAbort","signal","onabort","params","abortRequests","key","length","abort","getCorrelationId","parameter","split","map","part","find","sendGetRequestAsync","toJSON","sendPostRequestAsync"],"mappings":";AAAA;AACA;AACA,SAASA,cAAT,QAA+B,qBAA/B;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,MAAT,QAAuB,kBAAvB;AACA,SAASC,iBAAT,EAA4BC,qBAA5B,QAA0D,2BAA1D;AACA,SAASC,eAAT,QAAgC,yBAAhC;AACA,SAASC,mBAAT,EAA8BC,uBAA9B,QAA6D,WAA7D;AACA,SAASC,8BAAT,QAA+C,+BAA/C;AACA,SAASC,oBAAT,QAAqC,cAArC;AACA,SAASC,UAAT,QAA2B,iBAA3B;AACA,SAASC,MAAT,QAAuB,iBAAvB;AACA,MAAMC,eAAe,GAAG,iBAAxB;AACA;AACA;AACA;;AACA,OAAO,SAASC,8BAAT,CAAwCC,OAAxC,EAAiD;AACpD;AACA,MAAIC,aAAa,GAAGD,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACC,aAA9E,CAFoD,CAGpD;;AACA,MAAIb,MAAJ,EAAY;AACRa,IAAAA,aAAa,GAAGA,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqDA,aAArD,GAAqEC,OAAO,CAACC,GAAR,CAAYC,oBAAjG;AACH,GANmD,CAOpD;;;AACA,SAAOH,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqDA,aAArD,GAAqEN,oBAA5E;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMU,cAAN,SAA6BlB,aAA7B,CAA2C;AAC9CmB,EAAAA,WAAW,CAACN,OAAD,EAAU;AACjB,QAAIO,EAAJ;;AACA,UAAMC,cAAc,GAAI,yBAAxB;AACA,UAAMC,eAAe,GAAG,CAAC,CAACF,EAAE,GAAGP,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACU,gBAAhE,MAAsF,IAAtF,IAA8FH,EAAE,KAAK,KAAK,CAA1G,GAA8G,KAAK,CAAnH,GAAuHA,EAAE,CAACE,eAA3H,IACjB,GAAET,OAAO,CAACU,gBAAR,CAAyBD,eAAgB,IAAGD,cAAe,EAD5C,GAEjB,GAAEA,cAAe,EAFxB;AAGA,UAAMG,OAAO,GAAGZ,8BAA8B,CAACC,OAAD,CAA9C;;AACA,QAAI,CAACW,OAAO,CAACC,UAAR,CAAmB,QAAnB,CAAL,EAAmC;AAC/B,YAAM,IAAIC,KAAJ,CAAU,0DAAV,CAAN;AACH;;AACD,UAAMC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc;AAAEC,MAAAA,kBAAkB,EAAE,iCAAtB;AAAyDC,MAAAA,YAAY,EAAE;AACjGC,QAAAA,UAAU,EAAE;AADqF;AAAvE,KAAd,EAEXlB,OAFW,CAAd,EAEa;AAAEU,MAAAA,gBAAgB,EAAE;AAC/BD,QAAAA;AAD+B,OAApB;AAEZE,MAAAA;AAFY,KAFb,CAAN;AAKA,SAAKV,aAAL,GAAqBU,OAArB;AACA,SAAKQ,gBAAL,GAAwB,IAAIC,GAAJ,EAAxB;AACH;;AACKC,EAAAA,gBAAgB,CAACC,OAAD,EAAUC,eAAV,EAA2B;AAAA;;AAAA;AAC7C1B,MAAAA,MAAM,CAAC2B,IAAP,CAAa,6CAA4CF,OAAO,CAACG,GAAI,GAArE;AACA,YAAMC,QAAQ,SAAS,KAAI,CAACC,WAAL,CAAiBL,OAAjB,CAAvB;;AACAC,MAAAA,eAAe,GACXA,eAAe,KACTK,YAAD,IAAkB;AACf,eAAOC,IAAI,CAACC,GAAL,KAAaF,YAAY,CAACG,UAAb,GAA0B,IAA9C;AACH,OAHU,CADnB;;AAKA,UAAIL,QAAQ,CAACM,UAAT,KAAwBN,QAAQ,CAACO,MAAT,KAAoB,GAApB,IAA2BP,QAAQ,CAACO,MAAT,KAAoB,GAAvE,CAAJ,EAAiF;AAC7E,cAAMC,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWV,QAAQ,CAACM,UAApB,CAAnB;;AACA,YAAI,CAACE,UAAU,CAACG,YAAhB,EAA8B;AAC1B,iBAAO,IAAP;AACH;;AACD,cAAMC,KAAK,GAAG;AACVC,UAAAA,WAAW,EAAE;AACTD,YAAAA,KAAK,EAAEJ,UAAU,CAACG,YADT;AAETG,YAAAA,kBAAkB,EAAEjB,eAAe,CAACW,UAAD;AAF1B,WADH;AAKVO,UAAAA,YAAY,EAAEP,UAAU,CAACQ;AALf,SAAd;AAOA7C,QAAAA,MAAM,CAAC2B,IAAP,CAAa,oBAAmBF,OAAO,CAACG,GAAI,gCAA+Ba,KAAK,CAACC,WAAN,CAAkBC,kBAAmB,EAAhH;AACA,eAAOF,KAAP;AACH,OAdD,MAeK;AACD,cAAMK,KAAK,GAAG,IAAInD,mBAAJ,CAAwBkC,QAAQ,CAACO,MAAjC,EAAyCP,QAAQ,CAACM,UAAlD,CAAd;AACAnC,QAAAA,MAAM,CAAC+C,OAAP,CAAgB,sDAAqDlB,QAAQ,CAACO,MAAO,KAAIU,KAAK,CAACE,aAAN,CAAoBC,gBAAiB,EAA9H;AACA,cAAMH,KAAN;AACH;AA3B4C;AA4BhD;;AACKI,EAAAA,kBAAkB,CAACC,QAAD,EAAWC,QAAX,EAAqBC,MAArB,EAA6BT,YAA7B,EAA2CU,YAA3C,EAAyD5B,eAAzD,EAA0EvB,OAA1E,EAAmF;AAAA;;AAAA;AACvG,UAAIyC,YAAY,KAAKW,SAArB,EAAgC;AAC5B,eAAO,IAAP;AACH;;AACDvD,MAAAA,MAAM,CAAC2B,IAAP,CAAa,2DAA0DyB,QAAS,aAAYC,MAAO,UAAnG;AACA,YAAM;AAAEG,QAAAA,IAAF;AAAQC,QAAAA;AAAR,UAA2B1D,UAAU,CAAC,mCAAD,EAAsCI,OAAtC,CAA3C;AACA,YAAMuD,aAAa,GAAG;AAClBC,QAAAA,UAAU,EAAE,eADM;AAElBC,QAAAA,SAAS,EAAER,QAFO;AAGlBP,QAAAA,aAAa,EAAED,YAHG;AAIlBiB,QAAAA,KAAK,EAAER;AAJW,OAAtB;;AAMA,UAAIC,YAAY,KAAKC,SAArB,EAAgC;AAC5BG,QAAAA,aAAa,CAACI,aAAd,GAA8BR,YAA9B;AACH;;AACD,YAAMS,KAAK,GAAG,IAAIC,eAAJ,CAAoBN,aAApB,CAAd;;AACA,UAAI;AACA,cAAMO,SAAS,GAAGpE,8BAA8B,CAACsD,QAAD,CAAhD;AACA,cAAM1B,OAAO,GAAGhC,qBAAqB,CAAC;AAClCmC,UAAAA,GAAG,EAAG,GAAE,MAAI,CAACxB,aAAc,IAAG+C,QAAS,IAAGc,SAAU,EADlB;AAElCC,UAAAA,MAAM,EAAE,MAF0B;AAGlCC,UAAAA,IAAI,EAAEJ,KAAK,CAACK,QAAN,EAH4B;AAIlCC,UAAAA,WAAW,EAAElE,OAAO,IAAIA,OAAO,CAACkE,WAJE;AAKlCC,UAAAA,OAAO,EAAE9E,iBAAiB,CAAC;AACvB+E,YAAAA,MAAM,EAAE,kBADe;AAEvB,4BAAgB;AAFO,WAAD,CALQ;AASlCC,UAAAA,cAAc,EAAEf,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACe;AAT7D,SAAD,CAArC;AAWA,cAAM3C,QAAQ,SAAS,MAAI,CAACL,gBAAL,CAAsBC,OAAtB,EAA+BC,eAA/B,CAAvB;AACA1B,QAAAA,MAAM,CAAC2B,IAAP,CAAa,kDAAiDyB,QAAS,EAAvE;AACA,eAAOvB,QAAP;AACH,OAhBD,CAiBA,OAAO4C,GAAP,EAAY;AACR,YAAIA,GAAG,CAACC,IAAJ,KAAa9E,uBAAb,IACA6E,GAAG,CAACzB,aAAJ,CAAkBF,KAAlB,KAA4B,sBADhC,EACwD;AACpD;AACA;AACA;AACA9C,UAAAA,MAAM,CAAC2B,IAAP,CAAa,uDAAsDyB,QAAS,EAA5E;AACAI,UAAAA,IAAI,CAACmB,SAAL,CAAe;AACXC,YAAAA,IAAI,EAAEvF,cAAc,CAACwF,KADV;AAEXC,YAAAA,OAAO,EAAEL,GAAG,CAACK;AAFF,WAAf;AAIA,iBAAO,IAAP;AACH,SAXD,MAYK;AACD9E,UAAAA,MAAM,CAAC+C,OAAP,CAAgB,0DAAyDK,QAAS,KAAIqB,GAAI,EAA1F;AACAjB,UAAAA,IAAI,CAACmB,SAAL,CAAe;AACXC,YAAAA,IAAI,EAAEvF,cAAc,CAACwF,KADV;AAEXC,YAAAA,OAAO,EAAEL,GAAG,CAACK;AAFF,WAAf;AAIA,gBAAML,GAAN;AACH;AACJ,OAtCD,SAuCQ;AACJjB,QAAAA,IAAI,CAACuB,GAAL;AACH;AAzDsG;AA0D1G,GA1G6C,CA2G9C;AACA;;;AACAC,EAAAA,mBAAmB,CAACC,aAAD,EAAgB;AAC/B,UAAMC,UAAU,GAAG,IAAIxF,eAAJ,EAAnB;AACA,UAAMyF,WAAW,GAAG,KAAK7D,gBAAL,CAAsB8D,GAAtB,CAA0BH,aAA1B,KAA4C,EAAhE;AACAE,IAAAA,WAAW,CAACE,IAAZ,CAAiBH,UAAjB;AACA,SAAK5D,gBAAL,CAAsBgE,GAAtB,CAA0BL,aAA1B,EAAyCE,WAAzC;AACA,UAAMI,eAAe,GAAGL,UAAU,CAACM,MAAX,CAAkBC,OAA1C;;AACAP,IAAAA,UAAU,CAACM,MAAX,CAAkBC,OAAlB,GAA4B,CAAC,GAAGC,MAAJ,KAAe;AACvC,WAAKpE,gBAAL,CAAsBgE,GAAtB,CAA0BL,aAA1B,EAAyC1B,SAAzC;;AACA,UAAIgC,eAAJ,EAAqB;AACjBA,QAAAA,eAAe,CAAC,GAAGG,MAAJ,CAAf;AACH;AACJ,KALD;;AAMA,WAAOR,UAAU,CAACM,MAAlB;AACH;;AACDG,EAAAA,aAAa,CAACV,aAAD,EAAgB;AACzB,UAAMW,GAAG,GAAGX,aAAa,IAAIhF,eAA7B;AACA,UAAMkF,WAAW,GAAG,CAChB,IAAI,KAAK7D,gBAAL,CAAsB8D,GAAtB,CAA0BQ,GAA1B,KAAkC,EAAtC,CADgB,EAEhB;AACA,QAAI,KAAKtE,gBAAL,CAAsB8D,GAAtB,CAA0BnF,eAA1B,KAA8C,EAAlD,CAHgB,CAApB;;AAKA,QAAI,CAACkF,WAAW,CAACU,MAAjB,EAAyB;AACrB;AACH;;AACD,SAAK,MAAMX,UAAX,IAAyBC,WAAzB,EAAsC;AAClCD,MAAAA,UAAU,CAACY,KAAX;AACH;;AACD,SAAKxE,gBAAL,CAAsBgE,GAAtB,CAA0BM,GAA1B,EAA+BrC,SAA/B;AACH;;AACDwC,EAAAA,gBAAgB,CAAC5F,OAAD,EAAU;AACtB,QAAIO,EAAJ;;AACA,UAAMsF,SAAS,GAAG,CAACtF,EAAE,GAAGP,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACgE,IAAhE,MAA0E,IAA1E,IAAkFzD,EAAE,KAAK,KAAK,CAA9F,GAAkG,KAAK,CAAvG,GAA2GA,EAAE,CAACuF,KAAH,CAAS,GAAT,EAAcC,GAAd,CAAmBC,IAAD,IAAUA,IAAI,CAACF,KAAL,CAAW,GAAX,CAA5B,EAA6CG,IAA7C,CAAkD,CAAC,CAACR,GAAD,CAAD,KAAWA,GAAG,KAAK,mBAArE,CAA7H;AACA,WAAOI,SAAS,IAAIA,SAAS,CAACH,MAAvB,GAAgCG,SAAS,CAAC,CAAD,CAAT,IAAgB/F,eAAhD,GAAkEA,eAAzE;AACH,GA9I6C,CA+I9C;;;AACMoG,EAAAA,mBAAmB,CAACzE,GAAD,EAAMzB,OAAN,EAAe;AAAA;;AAAA;AACpC,YAAMsB,OAAO,GAAGhC,qBAAqB,CAAC;AAClCmC,QAAAA,GADkC;AAElCsC,QAAAA,MAAM,EAAE,KAF0B;AAGlCC,QAAAA,IAAI,EAAEhE,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACgE,IAH9B;AAIlCG,QAAAA,OAAO,EAAE9E,iBAAiB,CAACW,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACmE,OAA3D,CAJQ;AAKlCD,QAAAA,WAAW,EAAE,MAAI,CAACW,mBAAL,CAAyB/E,eAAzB;AALqB,OAAD,CAArC;AAOA,YAAM4B,QAAQ,SAAS,MAAI,CAACC,WAAL,CAAiBL,OAAjB,CAAvB;AACA,aAAO;AACH0C,QAAAA,IAAI,EAAEtC,QAAQ,CAACM,UAAT,GAAsBG,IAAI,CAACC,KAAL,CAAWV,QAAQ,CAACM,UAApB,CAAtB,GAAwDoB,SAD3D;AAEHe,QAAAA,OAAO,EAAEzC,QAAQ,CAACyC,OAAT,CAAiBgC,MAAjB,EAFN;AAGHlE,QAAAA,MAAM,EAAEP,QAAQ,CAACO;AAHd,OAAP;AAToC;AAcvC;;AACKmE,EAAAA,oBAAoB,CAAC3E,GAAD,EAAMzB,OAAN,EAAe;AAAA;;AAAA;AACrC,YAAMsB,OAAO,GAAGhC,qBAAqB,CAAC;AAClCmC,QAAAA,GADkC;AAElCsC,QAAAA,MAAM,EAAE,MAF0B;AAGlCC,QAAAA,IAAI,EAAEhE,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACgE,IAH9B;AAIlCG,QAAAA,OAAO,EAAE9E,iBAAiB,CAACW,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACmE,OAA3D,CAJQ;AAKlC;AACAD,QAAAA,WAAW,EAAE,MAAI,CAACW,mBAAL,CAAyB,MAAI,CAACe,gBAAL,CAAsB5F,OAAtB,CAAzB;AANqB,OAAD,CAArC;AAQA,YAAM0B,QAAQ,SAAS,MAAI,CAACC,WAAL,CAAiBL,OAAjB,CAAvB;AACA,aAAO;AACH0C,QAAAA,IAAI,EAAEtC,QAAQ,CAACM,UAAT,GAAsBG,IAAI,CAACC,KAAL,CAAWV,QAAQ,CAACM,UAApB,CAAtB,GAAwDoB,SAD3D;AAEHe,QAAAA,OAAO,EAAEzC,QAAQ,CAACyC,OAAT,CAAiBgC,MAAjB,EAFN;AAGHlE,QAAAA,MAAM,EAAEP,QAAQ,CAACO;AAHd,OAAP;AAVqC;AAexC;;AA9K6C","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest, } from \"@azure/core-rest-pipeline\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost } from \"../constants\";\nimport { createSpan } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options) {\n    // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n    let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n    // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n    if (isNode) {\n        authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n    }\n    // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n    return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient {\n    constructor(options) {\n        var _a;\n        const packageDetails = `azsdk-js-identity/2.0.4`;\n        const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix)\n            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n            : `${packageDetails}`;\n        const baseUri = getIdentityClientAuthorityHost(options);\n        if (!baseUri.startsWith(\"https:\")) {\n            throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n        }\n        super(Object.assign(Object.assign({ requestContentType: \"application/json; charset=utf-8\", retryOptions: {\n                maxRetries: 3,\n            } }, options), { userAgentOptions: {\n                userAgentPrefix,\n            }, baseUri }));\n        this.authorityHost = baseUri;\n        this.abortControllers = new Map();\n    }\n    async sendTokenRequest(request, expiresOnParser) {\n        logger.info(`IdentityClient: sending token request to [${request.url}]`);\n        const response = await this.sendRequest(request);\n        expiresOnParser =\n            expiresOnParser ||\n                ((responseBody) => {\n                    return Date.now() + responseBody.expires_in * 1000;\n                });\n        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n            const parsedBody = JSON.parse(response.bodyAsText);\n            if (!parsedBody.access_token) {\n                return null;\n            }\n            const token = {\n                accessToken: {\n                    token: parsedBody.access_token,\n                    expiresOnTimestamp: expiresOnParser(parsedBody),\n                },\n                refreshToken: parsedBody.refresh_token,\n            };\n            logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n            return token;\n        }\n        else {\n            const error = new AuthenticationError(response.status, response.bodyAsText);\n            logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n            throw error;\n        }\n    }\n    async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser, options) {\n        if (refreshToken === undefined) {\n            return null;\n        }\n        logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n        const { span, updatedOptions } = createSpan(\"IdentityClient-refreshAccessToken\", options);\n        const refreshParams = {\n            grant_type: \"refresh_token\",\n            client_id: clientId,\n            refresh_token: refreshToken,\n            scope: scopes,\n        };\n        if (clientSecret !== undefined) {\n            refreshParams.client_secret = clientSecret;\n        }\n        const query = new URLSearchParams(refreshParams);\n        try {\n            const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n            const request = createPipelineRequest({\n                url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,\n                method: \"POST\",\n                body: query.toString(),\n                abortSignal: options && options.abortSignal,\n                headers: createHttpHeaders({\n                    Accept: \"application/json\",\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                }),\n                tracingOptions: updatedOptions === null || updatedOptions === void 0 ? void 0 : updatedOptions.tracingOptions,\n            });\n            const response = await this.sendTokenRequest(request, expiresOnParser);\n            logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n            return response;\n        }\n        catch (err) {\n            if (err.name === AuthenticationErrorName &&\n                err.errorResponse.error === \"interaction_required\") {\n                // It's likely that the refresh token has expired, so\n                // return null so that the credential implementation will\n                // initiate the authentication flow again.\n                logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: err.message,\n                });\n                return null;\n            }\n            else {\n                logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: err.message,\n                });\n                throw err;\n            }\n        }\n        finally {\n            span.end();\n        }\n    }\n    // Here is a custom layer that allows us to abort requests that go through MSAL,\n    // since MSAL doesn't allow us to pass options all the way through.\n    generateAbortSignal(correlationId) {\n        const controller = new AbortController();\n        const controllers = this.abortControllers.get(correlationId) || [];\n        controllers.push(controller);\n        this.abortControllers.set(correlationId, controllers);\n        const existingOnAbort = controller.signal.onabort;\n        controller.signal.onabort = (...params) => {\n            this.abortControllers.set(correlationId, undefined);\n            if (existingOnAbort) {\n                existingOnAbort(...params);\n            }\n        };\n        return controller.signal;\n    }\n    abortRequests(correlationId) {\n        const key = correlationId || noCorrelationId;\n        const controllers = [\n            ...(this.abortControllers.get(key) || []),\n            // MSAL passes no correlation ID to the get requests...\n            ...(this.abortControllers.get(noCorrelationId) || []),\n        ];\n        if (!controllers.length) {\n            return;\n        }\n        for (const controller of controllers) {\n            controller.abort();\n        }\n        this.abortControllers.set(key, undefined);\n    }\n    getCorrelationId(options) {\n        var _a;\n        const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map((part) => part.split(\"=\")).find(([key]) => key === \"client-request-id\");\n        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n    }\n    // The MSAL network module methods follow\n    async sendGetRequestAsync(url, options) {\n        const request = createPipelineRequest({\n            url,\n            method: \"GET\",\n            body: options === null || options === void 0 ? void 0 : options.body,\n            headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n            abortSignal: this.generateAbortSignal(noCorrelationId),\n        });\n        const response = await this.sendRequest(request);\n        return {\n            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n            headers: response.headers.toJSON(),\n            status: response.status,\n        };\n    }\n    async sendPostRequestAsync(url, options) {\n        const request = createPipelineRequest({\n            url,\n            method: \"POST\",\n            body: options === null || options === void 0 ? void 0 : options.body,\n            headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n            // MSAL doesn't send the correlation ID on the get requests.\n            abortSignal: this.generateAbortSignal(this.getCorrelationId(options)),\n        });\n        const response = await this.sendRequest(request);\n        return {\n            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n            headers: response.headers.toJSON(),\n            status: response.status,\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}