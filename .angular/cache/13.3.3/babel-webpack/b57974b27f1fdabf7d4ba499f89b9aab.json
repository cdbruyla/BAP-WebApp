{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as utils from \"./util/utils\";\nimport { MapperType } from \"./serializer\";\nimport { DefaultDeserializationOptions, deserializationPolicy } from \"./policies/deserializationPolicy\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { DefaultRedirectOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { DefaultRetryOptions, exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { logPolicy } from \"./policies/logPolicy\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { getStreamResponseStatusCodes } from \"./operationSpec\";\nimport { WebResource, isWebResourceLike } from \"./webResource\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { isNode } from \"./util/utils\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { getDefaultUserAgentHeaderName, getDefaultUserAgentValue, userAgentPolicy } from \"./policies/userAgentPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { URL } from \"./url\";\nimport { URLBuilder } from \"./url\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { logger } from \"./log\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { stringifyXML } from \"./util/xml\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n/**\n * ServiceClient sends service requests and receives responses.\n */\n\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(credentials,\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n  options) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n    let requestPolicyFactories;\n\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory = undefined;\n\n      if (isTokenCredential(credentials)) {\n        logger.info(\"ServiceClient: creating bearer token authentication policy from provided credentials\"); // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n\n        const wrappedPolicyFactory = () => {\n          let bearerTokenPolicyFactory = undefined; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n          const serviceClient = this;\n          const serviceClientOptions = options;\n          return {\n            create(nextPolicy, createOptions) {\n              const credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);\n\n              if (!credentialScopes) {\n                throw new Error(`When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`);\n              }\n\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            }\n\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n\n\n  sendRequest(options) {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest;\n\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline = this._httpClient;\n\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n      }\n    }\n\n    return httpPipeline.sendRequest(httpRequest);\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n\n\n  sendOperationRequest(operationArguments, operationSpec, callback) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      if (typeof operationArguments.options === \"function\") {\n        callback = operationArguments.options;\n        operationArguments.options = undefined;\n      }\n\n      const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n      const httpRequest = new WebResource();\n      let result;\n\n      try {\n        const baseUri = operationSpec.baseUrl || _this.baseUri;\n\n        if (!baseUri) {\n          throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n        }\n\n        httpRequest.method = operationSpec.httpMethod;\n        httpRequest.operationSpec = operationSpec;\n        const requestUrl = URLBuilder.parse(baseUri);\n\n        if (operationSpec.path) {\n          requestUrl.appendPath(operationSpec.path);\n        }\n\n        if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n          for (const urlParameter of operationSpec.urlParameters) {\n            let urlParameterValue = getOperationArgumentValueFromParameter(_this, operationArguments, urlParameter, operationSpec.serializer);\n            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);\n\n            if (!urlParameter.skipEncoding) {\n              urlParameterValue = encodeURIComponent(urlParameterValue);\n            }\n\n            requestUrl.replaceAll(`{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`, urlParameterValue);\n          }\n        }\n\n        if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n          for (const queryParameter of operationSpec.queryParameters) {\n            let queryParameterValue = getOperationArgumentValueFromParameter(_this, operationArguments, queryParameter, operationSpec.serializer);\n\n            if (queryParameterValue !== undefined && queryParameterValue !== null) {\n              queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);\n\n              if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null) {\n                if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                  if (queryParameterValue.length === 0) {\n                    // The collection is empty, no need to try serializing the current queryParam\n                    continue;\n                  } else {\n                    for (const index in queryParameterValue) {\n                      const item = queryParameterValue[index];\n                      queryParameterValue[index] = item === undefined || item === null ? \"\" : item.toString();\n                    }\n                  }\n                } else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {\n                  queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                }\n              }\n\n              if (!queryParameter.skipEncoding) {\n                if (Array.isArray(queryParameterValue)) {\n                  for (const index in queryParameterValue) {\n                    if (queryParameterValue[index] !== undefined && queryParameterValue[index] !== null) {\n                      queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                    }\n                  }\n                } else {\n                  queryParameterValue = encodeURIComponent(queryParameterValue);\n                }\n              }\n\n              if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n\n              requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n            }\n          }\n        }\n\n        httpRequest.url = requestUrl.toString();\n        const contentType = operationSpec.contentType || _this.requestContentType;\n\n        if (contentType && operationSpec.requestBody) {\n          httpRequest.headers.set(\"Content-Type\", contentType);\n        }\n\n        if (operationSpec.headerParameters) {\n          for (const headerParameter of operationSpec.headerParameters) {\n            let headerValue = getOperationArgumentValueFromParameter(_this, operationArguments, headerParameter, operationSpec.serializer);\n\n            if (headerValue !== undefined && headerValue !== null) {\n              headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);\n              const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n\n              if (headerCollectionPrefix) {\n                for (const key of Object.keys(headerValue)) {\n                  httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                }\n              } else {\n                httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n              }\n            }\n          }\n        }\n\n        const options = operationArguments.options;\n\n        if (options) {\n          if (options.customHeaders) {\n            for (const customHeaderName in options.customHeaders) {\n              httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n            }\n          }\n\n          if (options.abortSignal) {\n            httpRequest.abortSignal = options.abortSignal;\n          }\n\n          if (options.timeout) {\n            httpRequest.timeout = options.timeout;\n          }\n\n          if (options.onUploadProgress) {\n            httpRequest.onUploadProgress = options.onUploadProgress;\n          }\n\n          if (options.onDownloadProgress) {\n            httpRequest.onDownloadProgress = options.onDownloadProgress;\n          }\n\n          if (options.spanOptions) {\n            // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n            httpRequest.spanOptions = options.spanOptions;\n          }\n\n          if (options.tracingContext) {\n            httpRequest.tracingContext = options.tracingContext;\n          }\n\n          if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n            httpRequest.shouldDeserialize = options.shouldDeserialize;\n          }\n        }\n\n        httpRequest.withCredentials = _this._withCredentials;\n        serializeRequestBody(_this, httpRequest, operationArguments, operationSpec);\n\n        if (httpRequest.streamResponseStatusCodes === undefined) {\n          httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n        }\n\n        let rawResponse;\n        let sendRequestError;\n\n        try {\n          rawResponse = yield _this.sendRequest(httpRequest);\n        } catch (error) {\n          sendRequestError = error;\n        }\n\n        if (sendRequestError) {\n          if (sendRequestError.response) {\n            sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses[\"default\"]);\n          }\n\n          result = Promise.reject(sendRequestError);\n        } else {\n          result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));\n        }\n      } catch (error) {\n        result = Promise.reject(error);\n      }\n\n      const cb = callback;\n\n      if (cb) {\n        result.then(res => cb(null, res._response.parsedBody, res._response.request, res._response)).catch(err => cb(err));\n      }\n\n      return result;\n    })();\n  }\n\n}\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n  var _a, _b, _c, _d, _e, _f;\n\n  const serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};\n  const updatedOptions = {\n    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : \"\",\n    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,\n    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY\n  };\n  const xmlCharKey = serializerOptions.xmlCharKey;\n\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      xmlName,\n      xmlElementName,\n      serializedName,\n      xmlNamespace,\n      xmlNamespacePrefix\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if (httpRequest.body !== undefined && httpRequest.body !== null || required) {\n        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);\n        const isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);\n\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          }\n        } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n      }\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\n\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: xmlNamespace\n    };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n  let result;\n\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(authPolicyFactory, options) {\n  const factories = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n  const userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({\n      key: userAgentHeaderName,\n      value: userAgentHeaderValue\n    }));\n  }\n\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n\n  factories.push(logPolicy({\n    logger: logger.info\n  }));\n  return factories;\n}\n/**\n * Creates an HTTP pipeline based on the given options.\n * @param pipelineOptions - Defines options that are used to configure policies in the HTTP pipeline for an SDK client.\n * @param authPolicyFactory - An optional authentication policy factory to use for signing requests.\n * @returns A set of options that can be passed to create a new {@link ServiceClient}.\n */\n\n\nexport function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {\n  const requestPolicyFactories = [];\n\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n\n  let userAgentValue = undefined;\n\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix); // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);\n  const retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);\n  const redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);\n\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n\n  const deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);\n  const loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);\n  requestPolicyFactories.push(tracingPolicy({\n    userAgent: userAgentValue\n  }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({\n    value: userAgentValue\n  }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories\n  };\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\n\nexport function getPropertyParent(parent, propertyPath) {\n  if (parent && propertyPath) {\n    const propertyPathLength = propertyPath.length;\n\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName = propertyPath[i];\n\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n\n      parent = parent[propertyName];\n    }\n  }\n\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\n\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n  var _a;\n\n  let value;\n\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n\n  const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue = parameterMapper.required || parameterPath[0] === \"options\" && parameterPath.length === 2;\n        }\n\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      } // Serialize just for validation purposes.\n\n\n      const parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper = parameterMapper.type.modelProperties[propertyName];\n      const propertyPath = parameterPath[propertyName];\n      const propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer); // Serialize just for validation purposes.\n\n      const propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n  const result = {\n    propertyFound: false\n  };\n  let i = 0;\n\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart = parameterPath[i]; // Make sure to check inherited properties too, so don't use hasOwnProperty().\n\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n\n  return result;\n}\n/**\n * Parses an {@link HttpOperationResponse} into a normalized HTTP response object ({@link RestResponse}).\n * @param _response - Wrapper object for http response.\n * @param responseSpec - Mappers for how to parse the response properties.\n * @returns - A normalized response object.\n */\n\n\nexport function flattenResponse(_response, responseSpec) {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = obj => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n\n    if (typeName === \"Stream\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      }));\n    }\n\n    const modelProperties = typeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n    const isPageableResponse = Object.keys(modelProperties).some(k => modelProperties[k].serializedName === \"\");\n\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n    }\n  }\n\n  if (bodyMapper || _response.request.method === \"HEAD\" || utils.isPrimitiveType(_response.parsedBody)) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n      body: _response.parsedBody\n    }));\n  }\n\n  return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n}\n\nfunction getCredentialScopes(options, baseUri) {\n  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes) ? scopes.map(scope => new URL(scope).toString()) : new URL(scopes).toString();\n  }\n\n  if (baseUri) {\n    return `${baseUri}/.default`;\n  }\n\n  return undefined;\n} //# sourceMappingURL=serviceClient.js.map","map":null,"metadata":{},"sourceType":"module"}