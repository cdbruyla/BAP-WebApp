{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { SpanKind, SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid } from \"@azure/core-tracing\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\n\nexport function tracingPolicy(tracingOptions = {}) {\n  return {\n    create(nextPolicy, options) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    }\n\n  };\n}\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\n\nexport class TracingPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, tracingOptions) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n\n  sendRequest(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!request.tracingContext) {\n        return _this._nextPolicy.sendRequest(request);\n      }\n\n      const span = _this.tryCreateSpan(request);\n\n      if (!span) {\n        return _this._nextPolicy.sendRequest(request);\n      }\n\n      try {\n        const response = yield _this._nextPolicy.sendRequest(request);\n\n        _this.tryProcessResponse(span, response);\n\n        return response;\n      } catch (err) {\n        _this.tryProcessError(span, err);\n\n        throw err;\n      }\n    })();\n  }\n\n  tryCreateSpan(request) {\n    var _a;\n\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const {\n        span\n      } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: Object.assign(Object.assign({}, request.spanOptions), {\n            kind: SpanKind.CLIENT\n          }),\n          tracingContext: request.tracingContext\n        }\n      }); // If the span is not recording, don't do any more work.\n\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n\n      const namespaceFromContext = (_a = request.tracingContext) === null || _a === void 0 ? void 0 : _a.getValue(Symbol.for(\"az.namespace\"));\n\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      });\n\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      } // set headers\n\n\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize(); // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n\n      return span;\n    } catch (error) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n\n  tryProcessError(span, err) {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message\n      });\n\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n  tryProcessResponse(span, response) {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n\n      span.setStatus({\n        code: SpanStatusCode.OK\n      });\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n} //# sourceMappingURL=tracingPolicy.js.map","map":null,"metadata":{},"sourceType":"module"}