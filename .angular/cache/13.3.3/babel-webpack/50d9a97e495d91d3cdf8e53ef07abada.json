{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"./constants\";\nimport { XML_ATTRKEY } from \"./serializer.common\";\nimport { v4 as uuidv4 } from \"uuid\";\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * A constant that indicates whether the environment is node.js or browser based.\n */\n\nexport const isNode = typeof process !== \"undefined\" && !!process.version && !!process.versions && !!process.versions.node;\n/**\n * Checks if a parsed URL is HTTPS\n *\n * @param urlToCheck - The url to check\n * @returns True if the URL is HTTPS; false otherwise.\n */\n\nexport function urlIsHTTPS(urlToCheck) {\n  return urlToCheck.protocol.toLowerCase() === Constants.HTTPS;\n}\n/**\n * Encodes an URI.\n *\n * @param uri - The URI to be encoded.\n * @returns The encoded URI.\n */\n\nexport function encodeUri(uri) {\n  return encodeURIComponent(uri).replace(/!/g, \"%21\").replace(/\"/g, \"%27\").replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\").replace(/\\*/g, \"%2A\");\n}\n/**\n * Returns a stripped version of the Http Response which only contains body,\n * headers and the status.\n *\n * @param response - The Http Response\n * @returns The stripped version of Http Response.\n */\n\nexport function stripResponse(response) {\n  const strippedResponse = {};\n  strippedResponse.body = response.bodyAsText;\n  strippedResponse.headers = response.headers;\n  strippedResponse.status = response.status;\n  return strippedResponse;\n}\n/**\n * Returns a stripped version of the Http Request that does not contain the\n * Authorization header.\n *\n * @param request - The Http Request object\n * @returns The stripped version of Http Request.\n */\n\nexport function stripRequest(request) {\n  const strippedRequest = request.clone();\n\n  if (strippedRequest.headers) {\n    strippedRequest.headers.remove(\"authorization\");\n  }\n\n  return strippedRequest;\n}\n/**\n * Validates the given uuid as a string\n *\n * @param uuid - The uuid as a string that needs to be validated\n * @returns True if the uuid is valid; false otherwise.\n */\n\nexport function isValidUuid(uuid) {\n  return validUuidRegex.test(uuid);\n}\n/**\n * Generated UUID\n *\n * @returns RFC4122 v4 UUID.\n */\n\nexport function generateUuid() {\n  return uuidv4();\n}\n/**\n * Executes an array of promises sequentially. Inspiration of this method is here:\n * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!\n *\n * @param promiseFactories - An array of promise factories(A function that return a promise)\n * @param kickstart - Input to the first promise that is used to kickstart the promise chain.\n * If not provided then the promise chain starts with undefined.\n * @returns A chain of resolved or rejected promises\n */\n\nexport function executePromisesSequentially(promiseFactories, kickstart) {\n  let result = Promise.resolve(kickstart);\n  promiseFactories.forEach(promiseFactory => {\n    result = result.then(promiseFactory);\n  });\n  return result;\n}\n/**\n * Converts a Promise to a callback.\n * @param promise - The Promise to be converted to a callback\n * @returns A function that takes the callback `(cb: Function) => void`\n * @deprecated generated code should instead depend on responseToBody\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nexport function promiseToCallback(promise) {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  } // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  return cb => {\n    promise.then(data => {\n      // eslint-disable-next-line promise/no-callback-in-promise\n      return cb(undefined, data);\n    }).catch(err => {\n      // eslint-disable-next-line promise/no-callback-in-promise\n      cb(err);\n    });\n  };\n}\n/**\n * Converts a Promise to a service callback.\n * @param promise - The Promise of HttpOperationResponse to be converted to a service callback\n * @returns A function that takes the service callback (cb: ServiceCallback<T>): void\n */\n\nexport function promiseToServiceCallback(promise) {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n\n  return cb => {\n    promise.then(data => {\n      return process.nextTick(cb, undefined, data.parsedBody, data.request, data);\n    }).catch(err => {\n      process.nextTick(cb, err);\n    });\n  };\n}\nexport function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n\n  if (!xmlNamespaceKey || !xmlNamespace) {\n    return {\n      [elementName]: obj\n    };\n  }\n\n  const result = {\n    [elementName]: obj\n  };\n  result[XML_ATTRKEY] = {\n    [xmlNamespaceKey]: xmlNamespace\n  };\n  return result;\n}\n/**\n * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor\n * @param targetCtor - The target object on which the properties need to be applied.\n * @param sourceCtors - An array of source objects from which the properties need to be taken.\n */\n\nexport function applyMixins(targetCtorParam, sourceCtors) {\n  const castTargetCtorParam = targetCtorParam;\n  sourceCtors.forEach(sourceCtor => {\n    Object.getOwnPropertyNames(sourceCtor.prototype).forEach(name => {\n      castTargetCtorParam.prototype[name] = sourceCtor.prototype[name];\n    });\n  });\n}\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Indicates whether the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @returns `true` if valid, `false` otherwise.\n */\n\nexport function isDuration(value) {\n  return validateISODuration.test(value);\n}\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param value - The value to search and replace in.\n * @param searchValue - The value to search for in the value argument.\n * @param replaceValue - The value to replace searchValue with in the value argument.\n * @returns The value where each instance of searchValue was replaced with replacedValue.\n */\n\nexport function replaceAll(value, searchValue, replaceValue) {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}\n/**\n * Determines whether the given entity is a basic/primitive type\n * (string, number, boolean, null, undefined).\n * @param value - Any entity\n * @returns true is it is primitive type, false otherwise.\n */\n\nexport function isPrimitiveType(value) {\n  return typeof value !== \"object\" && typeof value !== \"function\" || value === null;\n}\nexport function getEnvironmentValue(name) {\n  if (process.env[name]) {\n    return process.env[name];\n  } else if (process.env[name.toLowerCase()]) {\n    return process.env[name.toLowerCase()];\n  }\n\n  return undefined;\n}\n/**\n * @internal\n * @returns true when input is an object type that is not null, Array, RegExp, or Date.\n */\n\nexport function isObject(input) {\n  return typeof input === \"object\" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);\n} //# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module"}