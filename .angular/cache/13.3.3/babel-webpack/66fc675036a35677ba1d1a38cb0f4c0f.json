{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { IdentityClient } from \"../client/identityClient\";\nimport { credentialLogger, formatSuccess, formatError } from \"../util/logging\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { createSpan } from \"../util/tracing\";\nimport { checkTenantId } from \"../util/checkTenantId\";\nconst logger = credentialLogger(\"UsernamePasswordCredential\");\n/**\n * Enables authentication to Azure Active Directory with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n */\n\nexport class UsernamePasswordCredential {\n  /**\n   * Creates an instance of the UsernamePasswordCredential with the details\n   * needed to authenticate against Azure Active Directory with a username\n   * and password.\n   *\n   * @param tenantIdOrName - The Azure Active Directory tenant (directory) ID or name.\n   * @param clientId - The client (application) ID of an App Registration in the tenant.\n   * @param username - The user account's e-mail address (user name).\n   * @param password - The user account's account password\n   * @param options - Options for configuring the client which makes the authentication request.\n   */\n  constructor(tenantIdOrName, clientId, username, password, options) {\n    checkTenantId(logger, tenantIdOrName);\n    this.identityClient = new IdentityClient(options);\n    this.tenantId = tenantIdOrName;\n    this.clientId = clientId;\n    this.username = username;\n    this.password = password;\n  }\n  /**\n   * Authenticates with Azure Active Directory and returns an access token if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n\n\n  getToken(scopes, options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions: newOptions\n      } = createSpan(\"UsernamePasswordCredential.getToken\", options);\n\n      try {\n        const urlSuffix = getIdentityTokenEndpointSuffix(_this.tenantId);\n        const params = new URLSearchParams({\n          response_type: \"token\",\n          grant_type: \"password\",\n          client_id: _this.clientId,\n          username: _this.username,\n          password: _this.password,\n          scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \")\n        });\n        const webResource = createPipelineRequest({\n          url: `${_this.identityClient.authorityHost}/${_this.tenantId}/${urlSuffix}`,\n          method: \"POST\",\n          body: params.toString(),\n          headers: createHttpHeaders({\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n          }),\n          abortSignal: options && options.abortSignal,\n          tracingOptions: newOptions.tracingOptions\n        });\n        const tokenResponse = yield _this.identityClient.sendTokenRequest(webResource);\n        logger.getToken.info(formatSuccess(scopes));\n        return tokenResponse && tokenResponse.accessToken || null;\n      } catch (err) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message\n        });\n        logger.getToken.info(formatError(scopes, err));\n        throw err;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/identity/dist-esm/src/credentials/usernamePasswordCredential.browser.js"],"names":["createHttpHeaders","createPipelineRequest","SpanStatusCode","IdentityClient","credentialLogger","formatSuccess","formatError","getIdentityTokenEndpointSuffix","createSpan","checkTenantId","logger","UsernamePasswordCredential","constructor","tenantIdOrName","clientId","username","password","options","identityClient","tenantId","getToken","scopes","span","updatedOptions","newOptions","urlSuffix","params","URLSearchParams","response_type","grant_type","client_id","scope","join","webResource","url","authorityHost","method","body","toString","headers","Accept","abortSignal","tracingOptions","tokenResponse","sendTokenRequest","info","accessToken","err","setStatus","code","ERROR","message","end"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { IdentityClient } from \"../client/identityClient\";\nimport { credentialLogger, formatSuccess, formatError } from \"../util/logging\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { createSpan } from \"../util/tracing\";\nimport { checkTenantId } from \"../util/checkTenantId\";\nconst logger = credentialLogger(\"UsernamePasswordCredential\");\n/**\n * Enables authentication to Azure Active Directory with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n */\nexport class UsernamePasswordCredential {\n    /**\n     * Creates an instance of the UsernamePasswordCredential with the details\n     * needed to authenticate against Azure Active Directory with a username\n     * and password.\n     *\n     * @param tenantIdOrName - The Azure Active Directory tenant (directory) ID or name.\n     * @param clientId - The client (application) ID of an App Registration in the tenant.\n     * @param username - The user account's e-mail address (user name).\n     * @param password - The user account's account password\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(tenantIdOrName, clientId, username, password, options) {\n        checkTenantId(logger, tenantIdOrName);\n        this.identityClient = new IdentityClient(options);\n        this.tenantId = tenantIdOrName;\n        this.clientId = clientId;\n        this.username = username;\n        this.password = password;\n    }\n    /**\n     * Authenticates with Azure Active Directory and returns an access token if\n     * successful.  If authentication cannot be performed at this time, this method may\n     * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n     * containing failure details will be thrown.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options) {\n        const { span, updatedOptions: newOptions } = createSpan(\"UsernamePasswordCredential.getToken\", options);\n        try {\n            const urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);\n            const params = new URLSearchParams({\n                response_type: \"token\",\n                grant_type: \"password\",\n                client_id: this.clientId,\n                username: this.username,\n                password: this.password,\n                scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \"),\n            });\n            const webResource = createPipelineRequest({\n                url: `${this.identityClient.authorityHost}/${this.tenantId}/${urlSuffix}`,\n                method: \"POST\",\n                body: params.toString(),\n                headers: createHttpHeaders({\n                    Accept: \"application/json\",\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                }),\n                abortSignal: options && options.abortSignal,\n                tracingOptions: newOptions.tracingOptions,\n            });\n            const tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n            logger.getToken.info(formatSuccess(scopes));\n            return (tokenResponse && tokenResponse.accessToken) || null;\n        }\n        catch (err) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: err.message,\n            });\n            logger.getToken.info(formatError(scopes, err));\n            throw err;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}