{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid } from \"@azure/core-tracing\";\nimport { SpanKind } from \"@azure/core-tracing\";\nimport { getUserAgentValue } from \"../util/userAgent\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n/**\n * The programmatic identifier of the tracingPolicy.\n */\n\nexport const tracingPolicyName = \"tracingPolicy\";\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\n\nexport function tracingPolicy(options = {}) {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n  return {\n    name: tracingPolicyName,\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        var _a;\n\n        if (!((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) {\n          return next(request);\n        }\n\n        const span = tryCreateSpan(request, userAgent);\n\n        if (!span) {\n          return next(request);\n        }\n\n        try {\n          const response = yield next(request);\n          tryProcessResponse(span, response);\n          return response;\n        } catch (err) {\n          tryProcessError(span, err);\n          throw err;\n        }\n      })();\n    }\n\n  };\n}\n\nfunction tryCreateSpan(request, userAgent) {\n  var _a, _b, _c;\n\n  try {\n    const createSpanOptions = Object.assign(Object.assign({}, (_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.spanOptions), {\n      kind: SpanKind.CLIENT\n    }); // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n    // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n\n    const {\n      span\n    } = createSpan(`HTTP ${request.method}`, {\n      tracingOptions: Object.assign(Object.assign({}, request.tracingOptions), {\n        spanOptions: createSpanOptions\n      })\n    }); // If the span is not recording, don't do any more work.\n\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n\n    const namespaceFromContext = (_c = (_b = request.tracingOptions) === null || _b === void 0 ? void 0 : _b.tracingContext) === null || _c === void 0 ? void 0 : _c.getValue(Symbol.for(\"az.namespace\"));\n\n    if (typeof namespaceFromContext === \"string\") {\n      span.setAttribute(\"az.namespace\", namespaceFromContext);\n    }\n\n    span.setAttributes({\n      \"http.method\": request.method,\n      \"http.url\": request.url,\n      requestId: request.requestId\n    });\n\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    } // set headers\n\n\n    const spanContext = span.spanContext();\n    const traceParentHeader = getTraceParentHeader(spanContext);\n\n    if (traceParentHeader && isSpanContextValid(spanContext)) {\n      request.headers.set(\"traceparent\", traceParentHeader);\n      const traceState = spanContext.traceState && spanContext.traceState.serialize(); // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n\n      if (traceState) {\n        request.headers.set(\"tracestate\", traceState);\n      }\n    }\n\n    return span;\n  } catch (error) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n    return undefined;\n  }\n}\n\nfunction tryProcessError(span, err) {\n  try {\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: err.message\n    });\n\n    if (err.statusCode) {\n      span.setAttribute(\"http.status_code\", err.statusCode);\n    }\n\n    span.end();\n  } catch (error) {\n    logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n  }\n}\n\nfunction tryProcessResponse(span, response) {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n\n    span.setStatus({\n      code: SpanStatusCode.OK\n    });\n    span.end();\n  } catch (error) {\n    logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n  }\n} //# sourceMappingURL=tracingPolicy.js.map","map":null,"metadata":{},"sourceType":"module"}