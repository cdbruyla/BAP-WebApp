{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createClientLogger } from \"@azure/logger\";\nimport { decodeStringToString } from \"./base64\";\nconst defaultLogger = createClientLogger(\"authorizeRequestOnClaimChallenge\");\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Bearer d=\"e\", f=\"g\"`.\n * Into: `[ { a: 'b', c: 'd' }, { d: 'e', f: 'g' } ]`.\n *\n * @internal\n */\n\nexport function parseCAEChallenge(challenges) {\n  const bearerChallenges = `, ${challenges.trim()}`.split(\", Bearer \").filter(x => x);\n  return bearerChallenges.map(challenge => {\n    const challengeParts = `${challenge.trim()}, `.split('\", ').filter(x => x);\n    const keyValuePairs = challengeParts.map(keyValue => (([key, value]) => ({\n      [key]: value\n    }))(keyValue.trim().split('=\"'))); // Key-value pairs to plain object:\n\n    return keyValuePairs.reduce((a, b) => Object.assign(Object.assign({}, a), b), {});\n  });\n}\n/**\n * This function can be used as a callback for the `bearerTokenAuthenticationPolicy` of `@azure/core-rest-pipeline`, to support CAE challenges:\n * [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation).\n *\n * Call the `bearerTokenAuthenticationPolicy` with the following options:\n *\n * ```ts\n * import { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\n * import { authorizeRequestOnClaimChallenge } from \"@azure/core-client\";\n *\n * const bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy({\n *   authorizeRequestOnChallenge: authorizeRequestOnClaimChallenge\n * });\n * ```\n *\n * Once provided, the `bearerTokenAuthenticationPolicy` policy will internally handle Continuous Access Evaluation (CAE) challenges.\n * When it can't complete a challenge it will return the 401 (unauthorized) response from ARM.\n *\n * Example challenge with claims:\n *\n * ```\n * Bearer authorization_uri=\"https://login.windows-ppe.net/\", error=\"invalid_token\",\n * error_description=\"User session has been revoked\",\n * claims=\"eyJhY2Nlc3NfdG9rZW4iOnsibmJmIjp7ImVzc2VudGlhbCI6dHJ1ZSwgInZhbHVlIjoiMTYwMzc0MjgwMCJ9fX0=\"\n * ```\n */\n\nexport function authorizeRequestOnClaimChallenge(_x) {\n  return _authorizeRequestOnClaimChallenge.apply(this, arguments);\n} //# sourceMappingURL=authorizeRequestOnClaimChallenge.js.map\n\nfunction _authorizeRequestOnClaimChallenge() {\n  _authorizeRequestOnClaimChallenge = _asyncToGenerator(function* (onChallengeOptions) {\n    const {\n      scopes,\n      response\n    } = onChallengeOptions;\n    const logger = onChallengeOptions.logger || defaultLogger;\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n\n    if (!challenge) {\n      logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);\n      return false;\n    }\n\n    const challenges = parseCAEChallenge(challenge) || [];\n    const parsedChallenge = challenges.find(x => x.claims);\n\n    if (!parsedChallenge) {\n      logger.info(`The WWW-Authenticate header was missing the necessary \"claims\" to perform the Continuous Access Evaluation authentication flow.`);\n      return false;\n    }\n\n    const accessToken = yield onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {\n      claims: decodeStringToString(parsedChallenge.claims)\n    });\n\n    if (!accessToken) {\n      return false;\n    }\n\n    onChallengeOptions.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    return true;\n  });\n  return _authorizeRequestOnClaimChallenge.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}