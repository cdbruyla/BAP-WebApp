{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy, deserializationPolicy, generateUuid, HttpHeaders, WebResource, isTokenCredential, bearerTokenAuthenticationPolicy, isNode } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { BlobClient } from \"./Clients\";\nimport { Mutex } from \"./utils/Mutex\";\nimport { Pipeline } from \"./Pipeline\";\nimport { attachCredential, getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common\";\nimport { HeaderConstants, BATCH_MAX_REQUEST, HTTP_VERSION_1_1, HTTP_LINE_ENDING, StorageOAuthScopes } from \"./utils/constants\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { createSpan } from \"./utils/tracing\";\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\n\nexport class BlobBatch {\n  constructor() {\n    this.batch = \"batch\";\n    this.batchRequest = new InnerBatchRequest();\n  }\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n\n\n  getMultiPartContentType() {\n    return this.batchRequest.getMultipartContentType();\n  }\n  /**\n   * Get assembled HTTP request body for sub requests.\n   */\n\n\n  getHttpRequestBody() {\n    return this.batchRequest.getHttpRequestBody();\n  }\n  /**\n   * Get sub requests that are added into the batch request.\n   */\n\n\n  getSubRequests() {\n    return this.batchRequest.getSubRequests();\n  }\n\n  addSubRequestInternal(subRequest, assembleSubRequestFunc) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield Mutex.lock(_this.batch);\n\n      try {\n        _this.batchRequest.preAddSubRequest(subRequest);\n\n        yield assembleSubRequestFunc();\n\n        _this.batchRequest.postAddSubRequest(subRequest);\n      } finally {\n        yield Mutex.unlock(_this.batch);\n      }\n    })();\n  }\n\n  setBatchType(batchType) {\n    if (!this.batchType) {\n      this.batchType = batchType;\n    }\n\n    if (this.batchType !== batchType) {\n      throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);\n    }\n  }\n\n  deleteBlob(urlOrBlobClient, credentialOrOptions, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let url;\n      let credential;\n\n      if (typeof urlOrBlobClient === \"string\" && (isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || isTokenCredential(credentialOrOptions))) {\n        // First overload\n        url = urlOrBlobClient;\n        credential = credentialOrOptions;\n      } else if (urlOrBlobClient instanceof BlobClient) {\n        // Second overload\n        url = urlOrBlobClient.url;\n        credential = urlOrBlobClient.credential;\n        options = credentialOrOptions;\n      } else {\n        throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n      }\n\n      if (!options) {\n        options = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BatchDeleteRequest-addSubRequest\", options);\n\n      try {\n        _this2.setBatchType(\"delete\");\n\n        yield _this2.addSubRequestInternal({\n          url: url,\n          credential: credential\n        }, /*#__PURE__*/_asyncToGenerator(function* () {\n          yield new BlobClient(url, _this2.batchRequest.createPipeline(credential)).delete(updatedOptions);\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n  setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let url;\n      let credential;\n      let tier;\n\n      if (typeof urlOrBlobClient === \"string\" && (isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || isTokenCredential(credentialOrTier))) {\n        // First overload\n        url = urlOrBlobClient;\n        credential = credentialOrTier;\n        tier = tierOrOptions;\n      } else if (urlOrBlobClient instanceof BlobClient) {\n        // Second overload\n        url = urlOrBlobClient.url;\n        credential = urlOrBlobClient.credential;\n        tier = credentialOrTier;\n        options = tierOrOptions;\n      } else {\n        throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n      }\n\n      if (!options) {\n        options = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BatchSetTierRequest-addSubRequest\", options);\n\n      try {\n        _this3.setBatchType(\"setAccessTier\");\n\n        yield _this3.addSubRequestInternal({\n          url: url,\n          credential: credential\n        }, /*#__PURE__*/_asyncToGenerator(function* () {\n          yield new BlobClient(url, _this3.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n}\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\n\nclass InnerBatchRequest {\n  constructor() {\n    this.operationCount = 0;\n    this.body = \"\";\n    const tempGuid = generateUuid(); // batch_{batchid}\n\n    this.boundary = `batch_${tempGuid}`; // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n\n    this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`; // multipart/mixed; boundary=batch_{batchid}\n\n    this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`; // --batch_{batchid}--\n\n    this.batchRequestEnding = `--${this.boundary}--`;\n    this.subRequests = new Map();\n  }\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n\n\n  createPipeline(credential) {\n    const isAnonymousCreds = credential instanceof AnonymousCredential;\n    const policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1); // [deserializationPolicy, BatchHeaderFilterPolicyFactory, (Optional)Credential, BatchRequestAssemblePolicyFactory]\n\n    const factories = new Array(policyFactoryLength);\n    factories[0] = deserializationPolicy(); // Default deserializationPolicy is provided by protocol layer\n\n    factories[1] = new BatchHeaderFilterPolicyFactory(); // Use batch header filter policy to exclude unnecessary headers\n\n    if (!isAnonymousCreds) {\n      factories[2] = isTokenCredential(credential) ? attachCredential(bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes), credential) : credential;\n    }\n\n    factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this); // Use batch assemble policy to assemble request and intercept request from going to wire\n\n    return new Pipeline(factories, {});\n  }\n\n  appendSubRequestToBody(request) {\n    // Start to assemble sub request\n    this.body += [this.subRequestPrefix, `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`, \"\", `${request.method.toString()} ${getURLPathAndQuery(request.url)} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}` // sub request start line with method\n    ].join(HTTP_LINE_ENDING);\n\n    for (const header of request.headers.headersArray()) {\n      this.body += `${header.name}: ${header.value}${HTTP_LINE_ENDING}`;\n    }\n\n    this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n    // No body to assemble for current batch request support\n    // End to assemble sub request\n  }\n\n  preAddSubRequest(subRequest) {\n    if (this.operationCount >= BATCH_MAX_REQUEST) {\n      throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);\n    } // Fast fail if url for sub request is invalid\n\n\n    const path = getURLPath(subRequest.url);\n\n    if (!path || path === \"\") {\n      throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);\n    }\n  }\n\n  postAddSubRequest(subRequest) {\n    this.subRequests.set(this.operationCount, subRequest);\n    this.operationCount++;\n  } // Return the http request body with assembling the ending line to the sub request body.\n\n\n  getHttpRequestBody() {\n    return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;\n  }\n\n  getMultipartContentType() {\n    return this.multipartContentType;\n  }\n\n  getSubRequests() {\n    return this.subRequests;\n  }\n\n}\n\nclass BatchRequestAssemblePolicy extends BaseRequestPolicy {\n  constructor(batchRequest, nextPolicy, options) {\n    super(nextPolicy, options);\n    this.dummyResponse = {\n      request: new WebResource(),\n      status: 200,\n      headers: new HttpHeaders()\n    };\n    this.batchRequest = batchRequest;\n  }\n\n  sendRequest(request) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.batchRequest.appendSubRequestToBody(request);\n      return _this4.dummyResponse; // Intercept request from going to wire\n    })();\n  }\n\n}\n\nclass BatchRequestAssemblePolicyFactory {\n  constructor(batchRequest) {\n    this.batchRequest = batchRequest;\n  }\n\n  create(nextPolicy, options) {\n    return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);\n  }\n\n}\n\nclass BatchHeaderFilterPolicy extends BaseRequestPolicy {\n  // The base class has a protected constructor. Adding a public one to enable constructing of this class.\n\n  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/\n  constructor(nextPolicy, options) {\n    super(nextPolicy, options);\n  }\n\n  sendRequest(request) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      let xMsHeaderName = \"\";\n\n      for (const header of request.headers.headersArray()) {\n        if (iEqual(header.name, HeaderConstants.X_MS_VERSION)) {\n          xMsHeaderName = header.name;\n        }\n      }\n\n      if (xMsHeaderName !== \"\") {\n        request.headers.remove(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n      }\n\n      return _this5._nextPolicy.sendRequest(request);\n    })();\n  }\n\n}\n\nclass BatchHeaderFilterPolicyFactory {\n  create(nextPolicy, options) {\n    return new BatchHeaderFilterPolicy(nextPolicy, options);\n  }\n\n} //# sourceMappingURL=BlobBatch.js.map","map":null,"metadata":{},"sourceType":"module"}