{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createClientLogger } from \"@azure/logger\";\nimport { decodeStringToString } from \"./base64\";\nconst defaultLogger = createClientLogger(\"authorizeRequestOnClaimChallenge\");\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Bearer d=\"e\", f=\"g\"`.\n * Into: `[ { a: 'b', c: 'd' }, { d: 'e', f: 'g' } ]`.\n *\n * @internal\n */\n\nexport function parseCAEChallenge(challenges) {\n  const bearerChallenges = `, ${challenges.trim()}`.split(\", Bearer \").filter(x => x);\n  return bearerChallenges.map(challenge => {\n    const challengeParts = `${challenge.trim()}, `.split('\", ').filter(x => x);\n    const keyValuePairs = challengeParts.map(keyValue => (([key, value]) => ({\n      [key]: value\n    }))(keyValue.trim().split('=\"'))); // Key-value pairs to plain object:\n\n    return keyValuePairs.reduce((a, b) => Object.assign(Object.assign({}, a), b), {});\n  });\n}\n/**\n * This function can be used as a callback for the `bearerTokenAuthenticationPolicy` of `@azure/core-rest-pipeline`, to support CAE challenges:\n * [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation).\n *\n * Call the `bearerTokenAuthenticationPolicy` with the following options:\n *\n * ```ts\n * import { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\n * import { authorizeRequestOnClaimChallenge } from \"@azure/core-client\";\n *\n * const bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy({\n *   authorizeRequestOnChallenge: authorizeRequestOnClaimChallenge\n * });\n * ```\n *\n * Once provided, the `bearerTokenAuthenticationPolicy` policy will internally handle Continuous Access Evaluation (CAE) challenges.\n * When it can't complete a challenge it will return the 401 (unauthorized) response from ARM.\n *\n * Example challenge with claims:\n *\n * ```\n * Bearer authorization_uri=\"https://login.windows-ppe.net/\", error=\"invalid_token\",\n * error_description=\"User session has been revoked\",\n * claims=\"eyJhY2Nlc3NfdG9rZW4iOnsibmJmIjp7ImVzc2VudGlhbCI6dHJ1ZSwgInZhbHVlIjoiMTYwMzc0MjgwMCJ9fX0=\"\n * ```\n */\n\nexport function authorizeRequestOnClaimChallenge(_x) {\n  return _authorizeRequestOnClaimChallenge.apply(this, arguments);\n}\n\nfunction _authorizeRequestOnClaimChallenge() {\n  _authorizeRequestOnClaimChallenge = _asyncToGenerator(function* (onChallengeOptions) {\n    const {\n      scopes,\n      response\n    } = onChallengeOptions;\n    const logger = onChallengeOptions.logger || defaultLogger;\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n\n    if (!challenge) {\n      logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);\n      return false;\n    }\n\n    const challenges = parseCAEChallenge(challenge) || [];\n    const parsedChallenge = challenges.find(x => x.claims);\n\n    if (!parsedChallenge) {\n      logger.info(`The WWW-Authenticate header was missing the necessary \"claims\" to perform the Continuous Access Evaluation authentication flow.`);\n      return false;\n    }\n\n    const accessToken = yield onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {\n      claims: decodeStringToString(parsedChallenge.claims)\n    });\n\n    if (!accessToken) {\n      return false;\n    }\n\n    onChallengeOptions.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    return true;\n  });\n  return _authorizeRequestOnClaimChallenge.apply(this, arguments);\n}","map":{"version":3,"sources":["C:/GitHub/Private/Angular_WebApp/node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnClaimChallenge.js"],"names":["createClientLogger","decodeStringToString","defaultLogger","parseCAEChallenge","challenges","bearerChallenges","trim","split","filter","x","map","challenge","challengeParts","keyValuePairs","keyValue","key","value","reduce","a","b","Object","assign","authorizeRequestOnClaimChallenge","onChallengeOptions","scopes","response","logger","headers","get","info","parsedChallenge","find","claims","accessToken","getAccessToken","scope","request","set","token"],"mappings":";AAAA;AACA;AACA,SAASA,kBAAT,QAAmC,eAAnC;AACA,SAASC,oBAAT,QAAqC,UAArC;AACA,MAAMC,aAAa,GAAGF,kBAAkB,CAAC,kCAAD,CAAxC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,iBAAT,CAA2BC,UAA3B,EAAuC;AAC1C,QAAMC,gBAAgB,GAAI,KAAID,UAAU,CAACE,IAAX,EAAkB,EAAvB,CAAyBC,KAAzB,CAA+B,WAA/B,EAA4CC,MAA5C,CAAoDC,CAAD,IAAOA,CAA1D,CAAzB;AACA,SAAOJ,gBAAgB,CAACK,GAAjB,CAAsBC,SAAD,IAAe;AACvC,UAAMC,cAAc,GAAI,GAAED,SAAS,CAACL,IAAV,EAAiB,IAApB,CAAwBC,KAAxB,CAA8B,KAA9B,EAAqCC,MAArC,CAA6CC,CAAD,IAAOA,CAAnD,CAAvB;AACA,UAAMI,aAAa,GAAGD,cAAc,CAACF,GAAf,CAAoBI,QAAD,IAAc,CAAC,CAAC,CAACC,GAAD,EAAMC,KAAN,CAAD,MAAmB;AAAE,OAACD,GAAD,GAAOC;AAAT,KAAnB,CAAD,EAAuCF,QAAQ,CAACR,IAAT,GAAgBC,KAAhB,CAAsB,IAAtB,CAAvC,CAAjC,CAAtB,CAFuC,CAGvC;;AACA,WAAOM,aAAa,CAACI,MAAd,CAAqB,CAACC,CAAD,EAAIC,CAAJ,KAAWC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,CAAlB,CAAd,EAAoCC,CAApC,CAAhC,EAAyE,EAAzE,CAAP;AACH,GALM,CAAP;AAMH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,gBAAsBG,gCAAtB;AAAA;AAAA;;;wDAAO,WAAgDC,kBAAhD,EAAoE;AACvE,UAAM;AAAEC,MAAAA,MAAF;AAAUC,MAAAA;AAAV,QAAuBF,kBAA7B;AACA,UAAMG,MAAM,GAAGH,kBAAkB,CAACG,MAAnB,IAA6BxB,aAA5C;AACA,UAAMS,SAAS,GAAGc,QAAQ,CAACE,OAAT,CAAiBC,GAAjB,CAAqB,kBAArB,CAAlB;;AACA,QAAI,CAACjB,SAAL,EAAgB;AACZe,MAAAA,MAAM,CAACG,IAAP,CAAa,kHAAb;AACA,aAAO,KAAP;AACH;;AACD,UAAMzB,UAAU,GAAGD,iBAAiB,CAACQ,SAAD,CAAjB,IAAgC,EAAnD;AACA,UAAMmB,eAAe,GAAG1B,UAAU,CAAC2B,IAAX,CAAiBtB,CAAD,IAAOA,CAAC,CAACuB,MAAzB,CAAxB;;AACA,QAAI,CAACF,eAAL,EAAsB;AAClBJ,MAAAA,MAAM,CAACG,IAAP,CAAa,iIAAb;AACA,aAAO,KAAP;AACH;;AACD,UAAMI,WAAW,SAASV,kBAAkB,CAACW,cAAnB,CAAkCJ,eAAe,CAACK,KAAhB,GAAwB,CAACL,eAAe,CAACK,KAAjB,CAAxB,GAAkDX,MAApF,EAA4F;AAClHQ,MAAAA,MAAM,EAAE/B,oBAAoB,CAAC6B,eAAe,CAACE,MAAjB;AADsF,KAA5F,CAA1B;;AAGA,QAAI,CAACC,WAAL,EAAkB;AACd,aAAO,KAAP;AACH;;AACDV,IAAAA,kBAAkB,CAACa,OAAnB,CAA2BT,OAA3B,CAAmCU,GAAnC,CAAuC,eAAvC,EAAyD,UAASJ,WAAW,CAACK,KAAM,EAApF;AACA,WAAO,IAAP;AACH,G","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createClientLogger } from \"@azure/logger\";\nimport { decodeStringToString } from \"./base64\";\nconst defaultLogger = createClientLogger(\"authorizeRequestOnClaimChallenge\");\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Bearer d=\"e\", f=\"g\"`.\n * Into: `[ { a: 'b', c: 'd' }, { d: 'e', f: 'g' } ]`.\n *\n * @internal\n */\nexport function parseCAEChallenge(challenges) {\n    const bearerChallenges = `, ${challenges.trim()}`.split(\", Bearer \").filter((x) => x);\n    return bearerChallenges.map((challenge) => {\n        const challengeParts = `${challenge.trim()}, `.split('\", ').filter((x) => x);\n        const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('=\"')));\n        // Key-value pairs to plain object:\n        return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});\n    });\n}\n/**\n * This function can be used as a callback for the `bearerTokenAuthenticationPolicy` of `@azure/core-rest-pipeline`, to support CAE challenges:\n * [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation).\n *\n * Call the `bearerTokenAuthenticationPolicy` with the following options:\n *\n * ```ts\n * import { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\n * import { authorizeRequestOnClaimChallenge } from \"@azure/core-client\";\n *\n * const bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy({\n *   authorizeRequestOnChallenge: authorizeRequestOnClaimChallenge\n * });\n * ```\n *\n * Once provided, the `bearerTokenAuthenticationPolicy` policy will internally handle Continuous Access Evaluation (CAE) challenges.\n * When it can't complete a challenge it will return the 401 (unauthorized) response from ARM.\n *\n * Example challenge with claims:\n *\n * ```\n * Bearer authorization_uri=\"https://login.windows-ppe.net/\", error=\"invalid_token\",\n * error_description=\"User session has been revoked\",\n * claims=\"eyJhY2Nlc3NfdG9rZW4iOnsibmJmIjp7ImVzc2VudGlhbCI6dHJ1ZSwgInZhbHVlIjoiMTYwMzc0MjgwMCJ9fX0=\"\n * ```\n */\nexport async function authorizeRequestOnClaimChallenge(onChallengeOptions) {\n    const { scopes, response } = onChallengeOptions;\n    const logger = onChallengeOptions.logger || defaultLogger;\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (!challenge) {\n        logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);\n        return false;\n    }\n    const challenges = parseCAEChallenge(challenge) || [];\n    const parsedChallenge = challenges.find((x) => x.claims);\n    if (!parsedChallenge) {\n        logger.info(`The WWW-Authenticate header was missing the necessary \"claims\" to perform the Continuous Access Evaluation authentication flow.`);\n        return false;\n    }\n    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {\n        claims: decodeStringToString(parsedChallenge.claims),\n    });\n    if (!accessToken) {\n        return false;\n    }\n    onChallengeOptions.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    return true;\n}\n"]},"metadata":{},"sourceType":"module"}