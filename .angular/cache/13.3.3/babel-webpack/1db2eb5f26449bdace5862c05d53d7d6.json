{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar _a;\n\nimport { AbortError } from \"@azure/abort-controller\";\n/**\n * A constant that indicates whether the environment the code is running is Node.JS.\n * @internal\n */\n\nexport const isNode = typeof process !== \"undefined\" && Boolean(process.version) && Boolean((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node);\nconst StandardAbortMessage = \"The operation was aborted.\";\n/**\n * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.\n * @param delayInMs - The number of milliseconds to be delayed.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n * @param options - The options for delay - currently abort options\n *                  - abortSignal - The abortSignal associated with containing operation.\n *                  - abortErrorMsg - The abort error message associated with containing operation.\n * @returns Resolved promise\n */\n\nexport function delay(delayInMs, value, options) {\n  return new Promise((resolve, reject) => {\n    let timer = undefined;\n    let onAborted = undefined;\n\n    const rejectOnAbort = () => {\n      return reject(new AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));\n    };\n\n    const removeListeners = () => {\n      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {\n        options.abortSignal.removeEventListener(\"abort\", onAborted);\n      }\n    };\n\n    onAborted = () => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n\n      removeListeners();\n      return rejectOnAbort();\n    };\n\n    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {\n      return rejectOnAbort();\n    }\n\n    timer = setTimeout(() => {\n      removeListeners();\n      resolve(value);\n    }, delayInMs);\n\n    if (options === null || options === void 0 ? void 0 : options.abortSignal) {\n      options.abortSignal.addEventListener(\"abort\", onAborted);\n    }\n  });\n}\n/**\n * Returns a random integer value between a lower and upper bound,\n * inclusive of both bounds.\n * Note that this uses Math.random and isn't secure. If you need to use\n * this for any kind of security purpose, find a better source of random.\n * @param min - The smallest integer value allowed.\n * @param max - The largest integer value allowed.\n * @internal\n */\n\nexport function getRandomIntegerInclusive(min, max) {\n  // Make sure inputs are integers.\n  min = Math.ceil(min);\n  max = Math.floor(max); // Pick a random offset from zero to the size of the range.\n  // Since Math.random() can never return 1, we have to make the range one larger\n  // in order to be inclusive of the maximum value after we take the floor.\n\n  const offset = Math.floor(Math.random() * (max - min + 1));\n  return offset + min;\n}\n/**\n * @internal\n * @returns true when input is an object type that is not null, Array, RegExp, or Date.\n */\n\nexport function isObject(input) {\n  return typeof input === \"object\" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);\n}\n/**\n * @internal\n * @returns the parsed value or undefined if the parsed value is invalid.\n */\n\nexport function parseHeaderValueAsNumber(response, headerName) {\n  const value = response.headers.get(headerName);\n  if (!value) return;\n  const valueAsNum = Number(value);\n  if (Number.isNaN(valueAsNum)) return;\n  return valueAsNum;\n} //# sourceMappingURL=helpers.js.map","map":null,"metadata":{},"sourceType":"module"}