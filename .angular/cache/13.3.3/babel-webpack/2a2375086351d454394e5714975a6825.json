{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { getDefaultProxySettings, isNode, isTokenCredential, URLBuilder } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { Container } from \"./generated/src/operations\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { StorageClient } from \"./StorageClient\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery, BlobNameToString, ConvertInternalResponseOfListBlobFlat, ConvertInternalResponseOfListBlobHierarchy, extractConnectionStringParts, isIpEndpointStyle, parseObjectReplicationRecord, ProcessBlobItems, ProcessBlobPrefixes, toTags, truncatedISO8061Date } from \"./utils/utils.common\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\nimport { AppendBlobClient, BlobClient, BlockBlobClient, PageBlobClient } from \"./Clients\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\n/**\n * A ContainerClient represents a URL to the Azure Storage container allowing you to manipulate its blobs.\n */\n\nexport class ContainerClient extends StorageClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    let pipeline;\n    let url;\n    options = options || {};\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));\n\n          if (!options.proxyOptions) {\n            options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          }\n\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName parameter\");\n    }\n\n    super(url, pipeline);\n    this._containerName = this.getContainerNameFromUrl();\n    this.containerContext = new Container(this.storageClientContext);\n  }\n  /**\n   * The name of the container.\n   */\n\n\n  get containerName() {\n    return this._containerName;\n  }\n  /**\n   * Creates a new container under the specified account. If the container with\n   * the same name already exists, the operation fails.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param options - Options to Container Create operation.\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n   * const createContainerResponse = await containerClient.create();\n   * console.log(\"Container was created successfully\", createContainerResponse.requestId);\n   * ```\n   */\n\n\n  create(options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-create\", options);\n\n      try {\n        // Spread operator in destructuring assignments,\n        // this will filter out unwanted properties from the response object into result object\n        return yield _this.containerContext.create(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a new container under the specified account. If the container with\n   * the same name already exists, it is not changed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param options -\n   */\n\n\n  createIfNotExists(options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-createIfNotExists\", options);\n\n      try {\n        const res = yield _this2.create(updatedOptions);\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"ContainerAlreadyExists\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when creating a container only if it does not already exist.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns true if the Azure container resource represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing container might be deleted by other clients or\n   * applications. Vice versa new containers with the same name might be added by other clients or\n   * applications after this function completes.\n   *\n   * @param options -\n   */\n\n\n  exists(options = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-exists\", options);\n\n      try {\n        yield _this3.getProperties({\n          abortSignal: options.abortSignal,\n          tracingOptions: updatedOptions.tracingOptions\n        });\n        return true;\n      } catch (e) {\n        if (e.statusCode === 404) {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when checking container existence\"\n          });\n          return false;\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a {@link BlobClient}\n   *\n   * @param blobName - A blob name\n   * @returns A new BlobClient object for the given blob name.\n   */\n\n\n  getBlobClient(blobName) {\n    return new BlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n  }\n  /**\n   * Creates an {@link AppendBlobClient}\n   *\n   * @param blobName - An append blob name\n   */\n\n\n  getAppendBlobClient(blobName) {\n    return new AppendBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n  }\n  /**\n   * Creates a {@link BlockBlobClient}\n   *\n   * @param blobName - A block blob name\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   *\n   * const blockBlobClient = containerClient.getBlockBlobClient(\"<blob name>\");\n   * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n   * ```\n   */\n\n\n  getBlockBlobClient(blobName) {\n    return new BlockBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n  }\n  /**\n   * Creates a {@link PageBlobClient}\n   *\n   * @param blobName - A page blob name\n   */\n\n\n  getPageBlobClient(blobName) {\n    return new PageBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n  }\n  /**\n   * Returns all user-defined metadata and system properties for the specified\n   * container. The data returned does not include the container's list of blobs.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the `listContainers` method of {@link BlobServiceClient} using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @param options - Options to Container Get Properties operation.\n   */\n\n\n  getProperties(options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-getProperties\", options);\n\n      try {\n        return yield _this4.containerContext.getProperties(Object.assign(Object.assign({\n          abortSignal: options.abortSignal\n        }, options.conditions), convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified container for deletion. The container and any blobs\n   * contained within it are later deleted during garbage collection.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n   *\n   * @param options - Options to Container Delete operation.\n   */\n\n\n  delete(options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-delete\", options);\n\n      try {\n        return yield _this5.containerContext.delete(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified container for deletion if it exists. The container and any blobs\n   * contained within it are later deleted during garbage collection.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n   *\n   * @param options - Options to Container Delete operation.\n   */\n\n\n  deleteIfExists(options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-deleteIfExists\", options);\n\n      try {\n        const res = yield _this6.delete(updatedOptions);\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"ContainerNotFound\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when deleting a container only if it exists.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets one or more user-defined name-value pairs for the specified container.\n   *\n   * If no option provided, or no metadata defined in the parameter, the container\n   * metadata will be removed.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata\n   *\n   * @param metadata - Replace existing metadata with this value.\n   *                            If no value provided the existing metadata will be removed.\n   * @param options - Options to Container Set Metadata operation.\n   */\n\n\n  setMetadata(metadata, options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      if (options.conditions.ifUnmodifiedSince) {\n        throw new RangeError(\"the IfUnmodifiedSince must have their default values because they are ignored by the blob service\");\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-setMetadata\", options);\n\n      try {\n        return yield _this7.containerContext.setMetadata(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          metadata,\n          modifiedAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Gets the permissions for the specified container. The permissions indicate\n   * whether container data may be accessed publicly.\n   *\n   * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.\n   * For example, new Date(\"2018-12-31T03:44:23.8827891Z\").toISOString() will get \"2018-12-31T03:44:23.882Z\".\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl\n   *\n   * @param options - Options to Container Get Access Policy operation.\n   */\n\n\n  getAccessPolicy(options = {}) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-getAccessPolicy\", options);\n\n      try {\n        const response = yield _this8.containerContext.getAccessPolicy(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        const res = {\n          _response: response._response,\n          blobPublicAccess: response.blobPublicAccess,\n          date: response.date,\n          etag: response.etag,\n          errorCode: response.errorCode,\n          lastModified: response.lastModified,\n          requestId: response.requestId,\n          clientRequestId: response.clientRequestId,\n          signedIdentifiers: [],\n          version: response.version\n        };\n\n        for (const identifier of response) {\n          let accessPolicy = undefined;\n\n          if (identifier.accessPolicy) {\n            accessPolicy = {\n              permissions: identifier.accessPolicy.permissions\n            };\n\n            if (identifier.accessPolicy.expiresOn) {\n              accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);\n            }\n\n            if (identifier.accessPolicy.startsOn) {\n              accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);\n            }\n          }\n\n          res.signedIdentifiers.push({\n            accessPolicy,\n            id: identifier.id\n          });\n        }\n\n        return res;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets the permissions for the specified container. The permissions indicate\n   * whether blobs in a container may be accessed publicly.\n   *\n   * When you set permissions for a container, the existing permissions are replaced.\n   * If no access or containerAcl provided, the existing container ACL will be\n   * removed.\n   *\n   * When you establish a stored access policy on a container, it may take up to 30 seconds to take effect.\n   * During this interval, a shared access signature that is associated with the stored access policy will\n   * fail with status code 403 (Forbidden), until the access policy becomes active.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl\n   *\n   * @param access - The level of public access to data in the container.\n   * @param containerAcl - Array of elements each having a unique Id and details of the access policy.\n   * @param options - Options to Container Set Access Policy operation.\n   */\n\n\n  setAccessPolicy(access, containerAcl, options = {}) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-setAccessPolicy\", options);\n\n      try {\n        const acl = [];\n\n        for (const identifier of containerAcl || []) {\n          acl.push({\n            accessPolicy: {\n              expiresOn: identifier.accessPolicy.expiresOn ? truncatedISO8061Date(identifier.accessPolicy.expiresOn) : \"\",\n              permissions: identifier.accessPolicy.permissions,\n              startsOn: identifier.accessPolicy.startsOn ? truncatedISO8061Date(identifier.accessPolicy.startsOn) : \"\"\n            },\n            id: identifier.id\n          });\n        }\n\n        return yield _this9.containerContext.setAccessPolicy(Object.assign({\n          abortSignal: options.abortSignal,\n          access,\n          containerAcl: acl,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Get a {@link BlobLeaseClient} that manages leases on the container.\n   *\n   * @param proposeLeaseId - Initial proposed lease Id.\n   * @returns A new BlobLeaseClient object for managing leases on the container.\n   */\n\n\n  getBlobLeaseClient(proposeLeaseId) {\n    return new BlobLeaseClient(this, proposeLeaseId);\n  }\n  /**\n   * Creates a new block blob, or updates the content of an existing block blob.\n   *\n   * Updating an existing block blob overwrites any existing metadata on the blob.\n   * Partial updates are not supported; the content of the existing blob is\n   * overwritten with the new content. To perform a partial update of a block blob's,\n   * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.\n   *\n   * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},\n   * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better\n   * performance with concurrency uploading.\n   *\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param blobName - Name of the block blob to create or update.\n   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n   *                               which returns a new Readable stream whose offset is from data source beginning.\n   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n   *                               string including non non-Base64/Hex-encoded characters.\n   * @param options - Options to configure the Block Blob Upload operation.\n   * @returns Block Blob upload response data and the corresponding BlockBlobClient instance.\n   */\n\n\n  uploadBlockBlob(blobName, body, contentLength, options = {}) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-uploadBlockBlob\", options);\n\n      try {\n        const blockBlobClient = _this10.getBlockBlobClient(blobName);\n\n        const response = yield blockBlobClient.upload(body, contentLength, updatedOptions);\n        return {\n          blockBlobClient,\n          response\n        };\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified blob or snapshot for deletion. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param blobName -\n   * @param options - Options to Blob Delete operation.\n   * @returns Block blob deletion response data.\n   */\n\n\n  deleteBlob(blobName, options = {}) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-deleteBlob\", options);\n\n      try {\n        let blobClient = _this11.getBlobClient(blobName);\n\n        if (options.versionId) {\n          blobClient = blobClient.withVersion(options.versionId);\n        }\n\n        return yield blobClient.delete(updatedOptions);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * listBlobFlatSegment returns a single segment of blobs starting from the\n   * specified Marker. Use an empty Marker to start enumeration from the beginning.\n   * After getting a segment, process it, and then call listBlobsFlatSegment again\n   * (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n   *\n   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param options - Options to Container List Blob Flat Segment operation.\n   */\n\n\n  listBlobFlatSegment(marker, options = {}) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-listBlobFlatSegment\", options);\n\n      try {\n        const response = yield _this12.containerContext.listBlobFlatSegment(Object.assign(Object.assign({\n          marker\n        }, options), convertTracingToRequestOptionsBase(updatedOptions)));\n        response.segment.blobItems = [];\n\n        if (response.segment[\"Blob\"] !== undefined) {\n          response.segment.blobItems = ProcessBlobItems(response.segment[\"Blob\"]);\n        }\n\n        const wrappedResponse = Object.assign(Object.assign({}, response), {\n          _response: Object.assign(Object.assign({}, response._response), {\n            parsedBody: ConvertInternalResponseOfListBlobFlat(response._response.parsedBody)\n          }),\n          segment: Object.assign(Object.assign({}, response.segment), {\n            blobItems: response.segment.blobItems.map(blobItemInteral => {\n              const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n                name: BlobNameToString(blobItemInteral.name),\n                tags: toTags(blobItemInteral.blobTags),\n                objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)\n              });\n              return blobItem;\n            })\n          })\n        });\n        return wrappedResponse;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * listBlobHierarchySegment returns a single segment of blobs starting from\n   * the specified Marker. Use an empty Marker to start enumeration from the\n   * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment\n   * again (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param options - Options to Container List Blob Hierarchy Segment operation.\n   */\n\n\n  listBlobHierarchySegment(delimiter, marker, options = {}) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-listBlobHierarchySegment\", options);\n\n      try {\n        const response = yield _this13.containerContext.listBlobHierarchySegment(delimiter, Object.assign(Object.assign({\n          marker\n        }, options), convertTracingToRequestOptionsBase(updatedOptions)));\n        response.segment.blobItems = [];\n\n        if (response.segment[\"Blob\"] !== undefined) {\n          response.segment.blobItems = ProcessBlobItems(response.segment[\"Blob\"]);\n        }\n\n        response.segment.blobPrefixes = [];\n\n        if (response.segment[\"BlobPrefix\"] !== undefined) {\n          response.segment.blobPrefixes = ProcessBlobPrefixes(response.segment[\"BlobPrefix\"]);\n        }\n\n        const wrappedResponse = Object.assign(Object.assign({}, response), {\n          _response: Object.assign(Object.assign({}, response._response), {\n            parsedBody: ConvertInternalResponseOfListBlobHierarchy(response._response.parsedBody)\n          }),\n          segment: Object.assign(Object.assign({}, response.segment), {\n            blobItems: response.segment.blobItems.map(blobItemInteral => {\n              const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n                name: BlobNameToString(blobItemInteral.name),\n                tags: toTags(blobItemInteral.blobTags),\n                objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)\n              });\n              return blobItem;\n            }),\n            blobPrefixes: (_a = response.segment.blobPrefixes) === null || _a === void 0 ? void 0 : _a.map(blobPrefixInternal => {\n              const blobPrefix = {\n                name: BlobNameToString(blobPrefixInternal.name)\n              };\n              return blobPrefix;\n            })\n          })\n        });\n        return wrappedResponse;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse\n   *\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listSegments(marker, options = {}) {\n    return __asyncGenerator(this, arguments, function* listSegments_1() {\n      let listBlobsFlatSegmentResponse;\n\n      if (!!marker || marker === undefined) {\n        do {\n          listBlobsFlatSegmentResponse = yield __await(this.listBlobFlatSegment(marker, options));\n          marker = listBlobsFlatSegmentResponse.continuationToken;\n          yield yield __await(yield __await(listBlobsFlatSegmentResponse));\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator of {@link BlobItem} objects\n   *\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listItems(options = {}) {\n    return __asyncGenerator(this, arguments, function* listItems_1() {\n      var e_1, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.listSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const listBlobsFlatSegmentResponse = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to list all the blobs\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * // Get the containerClient before you run these snippets,\n   * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\");`\n   * let i = 1;\n   * for await (const blob of containerClient.listBlobsFlat()) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = containerClient.listBlobsFlat();\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {\n   *   for (const blob of response.segment.blobItems) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * for (const blob of response.segment.blobItems) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   *\n   * iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 blob names\n   * for (const blob of response.segment.blobItems) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   * ```\n   *\n   * @param options - Options to list blobs.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n\n\n  listBlobsFlat(options = {}) {\n    const include = [];\n\n    if (options.includeCopy) {\n      include.push(\"copy\");\n    }\n\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n\n    if (options.includeSnapshots) {\n      include.push(\"snapshots\");\n    }\n\n    if (options.includeVersions) {\n      include.push(\"versions\");\n    }\n\n    if (options.includeUncommitedBlobs) {\n      include.push(\"uncommittedblobs\");\n    }\n\n    if (options.includeTags) {\n      include.push(\"tags\");\n    }\n\n    if (options.includeDeletedWithVersions) {\n      include.push(\"deletedwithversions\");\n    }\n\n    if (options.includeImmutabilityPolicy) {\n      include.push(\"immutabilitypolicy\");\n    }\n\n    if (options.includeLegalHold) {\n      include.push(\"legalhold\");\n    }\n\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const updatedOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n      include: include\n    } : {}); // AsyncIterableIterator to iterate over blobs\n\n    const iter = this.listItems(updatedOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.listSegments(settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, updatedOptions));\n      }\n    };\n  }\n  /**\n   * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listHierarchySegments(delimiter, marker, options = {}) {\n    return __asyncGenerator(this, arguments, function* listHierarchySegments_1() {\n      let listBlobsHierarchySegmentResponse;\n\n      if (!!marker || marker === undefined) {\n        do {\n          listBlobsHierarchySegmentResponse = yield __await(this.listBlobHierarchySegment(delimiter, marker, options));\n          marker = listBlobsHierarchySegmentResponse.continuationToken;\n          yield yield __await(yield __await(listBlobsHierarchySegmentResponse));\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listItemsByHierarchy(delimiter, options = {}) {\n    return __asyncGenerator(this, arguments, function* listItemsByHierarchy_1() {\n      var e_2, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.listHierarchySegments(delimiter, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const listBlobsHierarchySegmentResponse = _c.value;\n          const segment = listBlobsHierarchySegmentResponse.segment;\n\n          if (segment.blobPrefixes) {\n            for (const prefix of segment.blobPrefixes) {\n              yield yield __await(Object.assign({\n                kind: \"prefix\"\n              }, prefix));\n            }\n          }\n\n          for (const blob of segment.blobItems) {\n            yield yield __await(Object.assign({\n              kind: \"blob\"\n            }, blob));\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to list all the blobs by hierarchy.\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * for await (const item of containerClient.listBlobsByHierarchy(\"/\")) {\n   *   if (item.kind === \"prefix\") {\n   *     console.log(`\\tBlobPrefix: ${item.name}`);\n   *   } else {\n   *     console.log(`\\tBlobItem: name - ${item.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let iter = containerClient.listBlobsByHierarchy(\"/\", { prefix: \"prefix1/\" });\n   * let entity = await iter.next();\n   * while (!entity.done) {\n   *   let item = entity.value;\n   *   if (item.kind === \"prefix\") {\n   *     console.log(`\\tBlobPrefix: ${item.name}`);\n   *   } else {\n   *     console.log(`\\tBlobItem: name - ${item.name}`);\n   *   }\n   *   entity = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * console.log(\"Listing blobs by hierarchy by page\");\n   * for await (const response of containerClient.listBlobsByHierarchy(\"/\").byPage()) {\n   *   const segment = response.segment;\n   *   if (segment.blobPrefixes) {\n   *     for (const prefix of segment.blobPrefixes) {\n   *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n   *     }\n   *   }\n   *   for (const blob of response.segment.blobItems) {\n   *     console.log(`\\tBlobItem: name - ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a max page size:\n   *\n   * ```js\n   * console.log(\"Listing blobs by hierarchy by page, specifying a prefix and a max page size\");\n   *\n   * let i = 1;\n   * for await (const response of containerClient\n   *   .listBlobsByHierarchy(\"/\", { prefix: \"prefix2/sub1/\" })\n   *   .byPage({ maxPageSize: 2 })) {\n   *   console.log(`Page ${i++}`);\n   *   const segment = response.segment;\n   *\n   *   if (segment.blobPrefixes) {\n   *     for (const prefix of segment.blobPrefixes) {\n   *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n   *     }\n   *   }\n   *\n   *   for (const blob of response.segment.blobItems) {\n   *     console.log(`\\tBlobItem: name - ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listBlobsByHierarchy(delimiter, options = {}) {\n    if (delimiter === \"\") {\n      throw new RangeError(\"delimiter should contain one or more characters\");\n    }\n\n    const include = [];\n\n    if (options.includeCopy) {\n      include.push(\"copy\");\n    }\n\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n\n    if (options.includeSnapshots) {\n      include.push(\"snapshots\");\n    }\n\n    if (options.includeVersions) {\n      include.push(\"versions\");\n    }\n\n    if (options.includeUncommitedBlobs) {\n      include.push(\"uncommittedblobs\");\n    }\n\n    if (options.includeTags) {\n      include.push(\"tags\");\n    }\n\n    if (options.includeDeletedWithVersions) {\n      include.push(\"deletedwithversions\");\n    }\n\n    if (options.includeImmutabilityPolicy) {\n      include.push(\"immutabilitypolicy\");\n    }\n\n    if (options.includeLegalHold) {\n      include.push(\"legalhold\");\n    }\n\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const updatedOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n      include: include\n    } : {}); // AsyncIterableIterator to iterate over blob prefixes and blobs\n\n    const iter = this.listItemsByHierarchy(delimiter, updatedOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return _asyncToGenerator(function* () {\n          return iter.next();\n        })();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.listHierarchySegments(delimiter, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, updatedOptions));\n      }\n    };\n  }\n  /**\n   * The Filter Blobs operation enables callers to list blobs in the container whose tags\n   * match a given search expression.\n   *\n   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                        The given expression must evaluate to true for a blob to be returned in the results.\n   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n\n\n  findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-findBlobsByTagsSegment\", options);\n\n      try {\n        const response = yield _this14.containerContext.filterBlobs(Object.assign({\n          abortSignal: options.abortSignal,\n          where: tagFilterSqlExpression,\n          marker,\n          maxPageSize: options.maxPageSize\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        const wrappedResponse = Object.assign(Object.assign({}, response), {\n          _response: response._response,\n          blobs: response.blobs.map(blob => {\n            var _a;\n\n            let tagValue = \"\";\n\n            if (((_a = blob.tags) === null || _a === void 0 ? void 0 : _a.blobTagSet.length) === 1) {\n              tagValue = blob.tags.blobTagSet[0].value;\n            }\n\n            return Object.assign(Object.assign({}, blob), {\n              tags: toTags(blob.tags),\n              tagValue\n            });\n          })\n        });\n        return wrappedResponse;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns an AsyncIterableIterator for ContainerFindBlobsByTagsSegmentResponse.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n\n\n  findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {\n    return __asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1() {\n      let response;\n\n      if (!!marker || marker === undefined) {\n        do {\n          response = yield __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options));\n          response.blobs = response.blobs || [];\n          marker = response.continuationToken;\n          yield yield __await(response);\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for blobs.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to findBlobsByTagsItems.\n   */\n\n\n  findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {\n    return __asyncGenerator(this, arguments, function* findBlobsByTagsItems_1() {\n      var e_3, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const segment = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(segment.blobs)));\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to find all blobs with specified tag\n   * under the specified container.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const blob of containerClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = containerClient.findBlobsByTags(\"tagkey='tagvalue'\");\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of containerClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n   *   if (response.blobs) {\n   *     for (const blob of response.blobs) {\n   *       console.log(`Blob ${i++}: ${blob.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = containerClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = containerClient\n   *   .findBlobsByTags(\"tagkey='tagvalue'\")\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *      console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to find blobs by tags.\n   */\n\n\n  findBlobsByTags(tagFilterSqlExpression, options = {}) {\n    // AsyncIterableIterator to iterate over blobs\n    const listSegmentOptions = Object.assign({}, options);\n    const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }\n    };\n  }\n\n  getContainerNameFromUrl() {\n    let containerName;\n\n    try {\n      //  URL may look like the following\n      // \"https://myaccount.blob.core.windows.net/mycontainer?sasString\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer\";\n      // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername`\n      // http://localhost:10001/devstoreaccount1/containername\n      const parsedUrl = URLBuilder.parse(this.url);\n\n      if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n        // \"https://myaccount.blob.core.windows.net/containername\".\n        // \"https://customdomain.com/containername\".\n        // .getPath() -> /containername\n        containerName = parsedUrl.getPath().split(\"/\")[1];\n      } else if (isIpEndpointStyle(parsedUrl)) {\n        // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername\n        // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername\n        // .getPath() -> /devstoreaccount1/containername\n        containerName = parsedUrl.getPath().split(\"/\")[2];\n      } else {\n        // \"https://customdomain.com/containername\".\n        // .getPath() -> /containername\n        containerName = parsedUrl.getPath().split(\"/\")[1];\n      } // decode the encoded containerName - to get all the special characters that might be present in it\n\n\n      containerName = decodeURIComponent(containerName);\n\n      if (!containerName) {\n        throw new Error(\"Provided containerName is invalid.\");\n      }\n\n      return containerName;\n    } catch (error) {\n      throw new Error(\"Unable to extract containerName with provided information.\");\n    }\n  }\n  /**\n   * Only available for ContainerClient constructed with a shared key credential.\n   *\n   * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n\n\n  generateSasUrl(options) {\n    return new Promise(resolve => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw new RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n      }\n\n      const sas = generateBlobSASQueryParameters(Object.assign({\n        containerName: this._containerName\n      }, options), this.credential).toString();\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n  /**\n   * Creates a BlobBatchClient object to conduct batch operations.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n   *\n   * @returns A new BlobBatchClient object for this container.\n   */\n\n\n  getBlobBatchClient() {\n    return new BlobBatchClient(this.url, this.pipeline);\n  }\n\n} //# sourceMappingURL=ContainerClient.js.map","map":null,"metadata":{},"sourceType":"module"}