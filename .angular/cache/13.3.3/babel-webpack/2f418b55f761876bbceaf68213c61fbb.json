{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\GitHub\\\\Private\\\\Angular_WebApp\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders, isNode, URLBuilder } from \"@azure/core-http\";\nimport { DevelopmentConnectionString, HeaderConstants, URLConstants } from \"./constants\";\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XxxClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" instead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\n\nexport function escapeURLPath(url) {\n  const urlParsed = URLBuilder.parse(url);\n  let path = urlParsed.getPath();\n  path = path || \"/\";\n  path = escape(path);\n  urlParsed.setPath(path);\n  return urlParsed.toString();\n}\n\nfunction getProxyUriFromDevConnString(connectionString) {\n  // Development Connection String\n  // https://docs.microsoft.com/en-us/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key\n  let proxyUri = \"\";\n\n  if (connectionString.search(\"DevelopmentStorageProxyUri=\") !== -1) {\n    // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri\n    const matchCredentials = connectionString.split(\";\");\n\n    for (const element of matchCredentials) {\n      if (element.trim().startsWith(\"DevelopmentStorageProxyUri=\")) {\n        proxyUri = element.trim().match(\"DevelopmentStorageProxyUri=(.*)\")[1];\n      }\n    }\n  }\n\n  return proxyUri;\n}\n\nexport function getValueInConnString(connectionString, argument) {\n  const elements = connectionString.split(\";\");\n\n  for (const element of elements) {\n    if (element.trim().startsWith(argument)) {\n      return element.trim().match(argument + \"=(.*)\")[1];\n    }\n  }\n\n  return \"\";\n}\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\n\nexport function extractConnectionStringParts(connectionString) {\n  let proxyUri = \"\";\n\n  if (connectionString.startsWith(\"UseDevelopmentStorage=true\")) {\n    // Development connection string\n    proxyUri = getProxyUriFromDevConnString(connectionString);\n    connectionString = DevelopmentConnectionString;\n  } // Matching BlobEndpoint in the Account connection string\n\n\n  let blobEndpoint = getValueInConnString(connectionString, \"BlobEndpoint\"); // Slicing off '/' at the end if exists\n  // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n\n  blobEndpoint = blobEndpoint.endsWith(\"/\") ? blobEndpoint.slice(0, -1) : blobEndpoint;\n\n  if (connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 && connectionString.search(\"AccountKey=\") !== -1) {\n    // Account connection string\n    let defaultEndpointsProtocol = \"\";\n    let accountName = \"\";\n    let accountKey = Buffer.from(\"accountKey\", \"base64\");\n    let endpointSuffix = \"\"; // Get account name and key\n\n    accountName = getValueInConnString(connectionString, \"AccountName\");\n    accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n\n    if (!blobEndpoint) {\n      // BlobEndpoint is not present in the Account connection string\n      // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`\n      defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n      const protocol = defaultEndpointsProtocol.toLowerCase();\n\n      if (protocol !== \"https\" && protocol !== \"http\") {\n        throw new Error(\"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\");\n      }\n\n      endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n\n      if (!endpointSuffix) {\n        throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n      }\n\n      blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n    }\n\n    if (!accountName) {\n      throw new Error(\"Invalid AccountName in the provided Connection String\");\n    } else if (accountKey.length === 0) {\n      throw new Error(\"Invalid AccountKey in the provided Connection String\");\n    }\n\n    return {\n      kind: \"AccountConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountKey,\n      proxyUri\n    };\n  } else {\n    // SAS connection string\n    const accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n    const accountName = getAccountNameFromUrl(blobEndpoint);\n\n    if (!blobEndpoint) {\n      throw new Error(\"Invalid BlobEndpoint in the provided SAS Connection String\");\n    } else if (!accountSas) {\n      throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n    }\n\n    return {\n      kind: \"SASConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountSas\n    };\n  }\n}\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\n\nfunction escape(text) {\n  return encodeURIComponent(text).replace(/%2F/g, \"/\") // Don't escape for \"/\"\n  .replace(/'/g, \"%27\") // Escape for \"'\"\n  .replace(/\\+/g, \"%20\").replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\n\n\nexport function appendToURLPath(url, name) {\n  const urlParsed = URLBuilder.parse(url);\n  let path = urlParsed.getPath();\n  path = path ? path.endsWith(\"/\") ? `${path}${name}` : `${path}/${name}` : name;\n  urlParsed.setPath(path);\n  return urlParsed.toString();\n}\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\n\nexport function setURLParameter(url, name, value) {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setQueryParameter(name, value);\n  return urlParsed.toString();\n}\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\n\nexport function getURLParameter(url, name) {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getQueryParameterValue(name);\n}\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\n\nexport function setURLHost(url, host) {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setHost(host);\n  return urlParsed.toString();\n}\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\n\nexport function getURLPath(url) {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getPath();\n}\n/**\n * Get URL scheme from an URL string.\n *\n * @param url - Source URL string\n */\n\nexport function getURLScheme(url) {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getScheme();\n}\n/**\n * Get URL path and query from an URL string.\n *\n * @param url - Source URL string\n */\n\nexport function getURLPathAndQuery(url) {\n  const urlParsed = URLBuilder.parse(url);\n  const pathString = urlParsed.getPath();\n\n  if (!pathString) {\n    throw new RangeError(\"Invalid url without valid path.\");\n  }\n\n  let queryString = urlParsed.getQuery() || \"\";\n  queryString = queryString.trim();\n\n  if (queryString !== \"\") {\n    queryString = queryString.startsWith(\"?\") ? queryString : `?${queryString}`; // Ensure query string start with '?'\n  }\n\n  return `${pathString}${queryString}`;\n}\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\n\nexport function getURLQueries(url) {\n  let queryString = URLBuilder.parse(url).getQuery();\n\n  if (!queryString) {\n    return {};\n  }\n\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substr(1) : queryString;\n  let querySubStrings = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter(value => {\n    const indexOfEqual = value.indexOf(\"=\");\n    const lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;\n  });\n  const queries = {};\n\n  for (const querySubString of querySubStrings) {\n    const splitResults = querySubString.split(\"=\");\n    const key = splitResults[0];\n    const value = splitResults[1];\n    queries[key] = value;\n  }\n\n  return queries;\n}\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\n\nexport function appendToURLQuery(url, queryParts) {\n  const urlParsed = URLBuilder.parse(url);\n  let query = urlParsed.getQuery();\n\n  if (query) {\n    query += \"&\" + queryParts;\n  } else {\n    query = queryParts;\n  }\n\n  urlParsed.setQuery(query);\n  return urlParsed.toString();\n}\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\n\nexport function truncatedISO8061Date(date, withMilliseconds = true) {\n  // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n  const dateString = date.toISOString();\n  return withMilliseconds ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\" : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n/**\n * Base64 encode.\n *\n * @param content -\n */\n\nexport function base64encode(content) {\n  return !isNode ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\n\nexport function base64decode(encodedString) {\n  return !isNode ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @param blockIndex -\n */\n\nexport function generateBlockID(blockIDPrefix, blockIndex) {\n  // To generate a 64 bytes base64 string, source string should be 48\n  const maxSourceStringLength = 48; // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n\n  const maxBlockIndexLength = 6;\n  const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n\n  if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n    blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n  }\n\n  const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n  return base64encode(res);\n}\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\n\nexport function delay(_x, _x2, _x3) {\n  return _delay.apply(this, arguments);\n}\n/**\n * String.prototype.padStart()\n *\n * @param currentString -\n * @param targetLength -\n * @param padString -\n */\n\nfunction _delay() {\n  _delay = _asyncToGenerator(function* (timeInMs, aborter, abortError) {\n    return new Promise((resolve, reject) => {\n      /* eslint-disable-next-line prefer-const */\n      let timeout;\n\n      const abortHandler = () => {\n        if (timeout !== undefined) {\n          clearTimeout(timeout);\n        }\n\n        reject(abortError);\n      };\n\n      const resolveHandler = () => {\n        if (aborter !== undefined) {\n          aborter.removeEventListener(\"abort\", abortHandler);\n        }\n\n        resolve();\n      };\n\n      timeout = setTimeout(resolveHandler, timeInMs);\n\n      if (aborter !== undefined) {\n        aborter.addEventListener(\"abort\", abortHandler);\n      }\n    });\n  });\n  return _delay.apply(this, arguments);\n}\n\nexport function padStart(currentString, targetLength, padString = \" \") {\n  // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes\n  if (String.prototype.padStart) {\n    return currentString.padStart(targetLength, padString);\n  }\n\n  padString = padString || \" \";\n\n  if (currentString.length > targetLength) {\n    return currentString;\n  } else {\n    targetLength = targetLength - currentString.length;\n\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n\n    return padString.slice(0, targetLength) + currentString;\n  }\n}\nexport function sanitizeURL(url) {\n  let safeURL = url;\n\n  if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n    safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n  }\n\n  return safeURL;\n}\nexport function sanitizeHeaders(originalHeader) {\n  const headers = new HttpHeaders();\n\n  for (const header of originalHeader.headersArray()) {\n    if (header.name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n      headers.set(header.name, \"*****\");\n    } else if (header.name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n      headers.set(header.name, sanitizeURL(header.value));\n    } else {\n      headers.set(header.name, header.value);\n    }\n  }\n\n  return headers;\n}\n/**\n * If two strings are equal when compared case insensitive.\n *\n * @param str1 -\n * @param str2 -\n */\n\nexport function iEqual(str1, str2) {\n  return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();\n}\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\n\nexport function getAccountNameFromUrl(url) {\n  const parsedUrl = URLBuilder.parse(url);\n  let accountName;\n\n  try {\n    if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n      // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n      accountName = parsedUrl.getHost().split(\".\")[0];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n      // .getPath() -> /devstoreaccount1/\n      accountName = parsedUrl.getPath().split(\"/\")[1];\n    } else {\n      // Custom domain case: \"https://customdomain.com/containername/blob\".\n      accountName = \"\";\n    }\n\n    return accountName;\n  } catch (error) {\n    throw new Error(\"Unable to extract accountName with provided information.\");\n  }\n}\nexport function isIpEndpointStyle(parsedUrl) {\n  if (parsedUrl.getHost() === undefined) {\n    return false;\n  }\n\n  const host = parsedUrl.getHost() + (parsedUrl.getPort() === undefined ? \"\" : \":\" + parsedUrl.getPort()); // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n  // Case 2: localhost(:port), use broad regex to match port part.\n  // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n  // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n\n  return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(host);\n}\n/**\n * Convert Tags to encoded string.\n *\n * @param tags -\n */\n\nexport function toBlobTagsString(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const tagPairs = [];\n\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n    }\n  }\n\n  return tagPairs.join(\"&\");\n}\n/**\n * Convert Tags type to BlobTags.\n *\n * @param tags -\n */\n\nexport function toBlobTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res = {\n    blobTagSet: []\n  };\n\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      res.blobTagSet.push({\n        key,\n        value\n      });\n    }\n  }\n\n  return res;\n}\n/**\n * Covert BlobTags to Tags type.\n *\n * @param tags -\n */\n\nexport function toTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res = {};\n\n  for (const blobTag of tags.blobTagSet) {\n    res[blobTag.key] = blobTag.value;\n  }\n\n  return res;\n}\n/**\n * Convert BlobQueryTextConfiguration to QuerySerialization type.\n *\n * @param textConfiguration -\n */\n\nexport function toQuerySerialization(textConfiguration) {\n  if (textConfiguration === undefined) {\n    return undefined;\n  }\n\n  switch (textConfiguration.kind) {\n    case \"csv\":\n      return {\n        format: {\n          type: \"delimited\",\n          delimitedTextConfiguration: {\n            columnSeparator: textConfiguration.columnSeparator || \",\",\n            fieldQuote: textConfiguration.fieldQuote || \"\",\n            recordSeparator: textConfiguration.recordSeparator,\n            escapeChar: textConfiguration.escapeCharacter || \"\",\n            headersPresent: textConfiguration.hasHeaders || false\n          }\n        }\n      };\n\n    case \"json\":\n      return {\n        format: {\n          type: \"json\",\n          jsonTextConfiguration: {\n            recordSeparator: textConfiguration.recordSeparator\n          }\n        }\n      };\n\n    case \"arrow\":\n      return {\n        format: {\n          type: \"arrow\",\n          arrowConfiguration: {\n            schema: textConfiguration.schema\n          }\n        }\n      };\n\n    case \"parquet\":\n      return {\n        format: {\n          type: \"parquet\"\n        }\n      };\n\n    default:\n      throw Error(\"Invalid BlobQueryTextConfiguration.\");\n  }\n}\nexport function parseObjectReplicationRecord(objectReplicationRecord) {\n  if (!objectReplicationRecord) {\n    return undefined;\n  }\n\n  if (\"policy-id\" in objectReplicationRecord) {\n    // If the dictionary contains a key with policy id, we are not required to do any parsing since\n    // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.\n    return undefined;\n  }\n\n  const orProperties = [];\n\n  for (const key in objectReplicationRecord) {\n    const ids = key.split(\"_\");\n    const policyPrefix = \"or-\";\n\n    if (ids[0].startsWith(policyPrefix)) {\n      ids[0] = ids[0].substring(policyPrefix.length);\n    }\n\n    const rule = {\n      ruleId: ids[1],\n      replicationStatus: objectReplicationRecord[key]\n    };\n    const policyIndex = orProperties.findIndex(policy => policy.policyId === ids[0]);\n\n    if (policyIndex > -1) {\n      orProperties[policyIndex].rules.push(rule);\n    } else {\n      orProperties.push({\n        policyId: ids[0],\n        rules: [rule]\n      });\n    }\n  }\n\n  return orProperties;\n}\n/**\n * Attach a TokenCredential to an object.\n *\n * @param thing -\n * @param credential -\n */\n\nexport function attachCredential(thing, credential) {\n  thing.credential = credential;\n  return thing;\n}\nexport function httpAuthorizationToString(httpAuthorization) {\n  return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\nexport function BlobNameToString(name) {\n  if (name.encoded) {\n    return decodeURIComponent(name.content);\n  } else {\n    return name.content;\n  }\n}\nexport function ConvertInternalResponseOfListBlobFlat(internalResponse) {\n  return Object.assign(Object.assign({}, internalResponse), {\n    segment: {\n      blobItems: internalResponse.segment.blobItems.map(blobItemInteral => {\n        const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n          name: BlobNameToString(blobItemInteral.name)\n        });\n        return blobItem;\n      })\n    }\n  });\n}\nexport function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {\n  var _a;\n\n  return Object.assign(Object.assign({}, internalResponse), {\n    segment: {\n      blobPrefixes: (_a = internalResponse.segment.blobPrefixes) === null || _a === void 0 ? void 0 : _a.map(blobPrefixInternal => {\n        const blobPrefix = {\n          name: BlobNameToString(blobPrefixInternal.name)\n        };\n        return blobPrefix;\n      }),\n      blobItems: internalResponse.segment.blobItems.map(blobItemInteral => {\n        const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n          name: BlobNameToString(blobItemInteral.name)\n        });\n        return blobItem;\n      })\n    }\n  });\n}\n\nfunction decodeBase64String(value) {\n  if (isNode) {\n    return Buffer.from(value, \"base64\");\n  } else {\n    const byteString = atob(value);\n    const arr = new Uint8Array(byteString.length);\n\n    for (let i = 0; i < byteString.length; i++) {\n      arr[i] = byteString.charCodeAt(i);\n    }\n\n    return arr;\n  }\n}\n\nfunction ParseBoolean(content) {\n  if (content === undefined) return undefined;\n  if (content === \"true\") return true;\n  if (content === \"false\") return false;\n  return undefined;\n}\n\nfunction ParseBlobName(blobNameInXML) {\n  if (blobNameInXML[\"$\"] !== undefined && blobNameInXML[\"#\"] !== undefined) {\n    return {\n      encoded: ParseBoolean(blobNameInXML[\"$\"][\"Encoded\"]),\n      content: blobNameInXML[\"#\"]\n    };\n  } else {\n    return {\n      encoded: false,\n      content: blobNameInXML\n    };\n  }\n}\n\nfunction ParseBlobItem(blobInXML) {\n  const blobPropertiesInXML = blobInXML[\"Properties\"];\n  const blobProperties = {\n    createdOn: new Date(blobPropertiesInXML[\"Creation-Time\"]),\n    lastModified: new Date(blobPropertiesInXML[\"Last-Modified\"]),\n    etag: blobPropertiesInXML[\"Etag\"],\n    contentLength: blobPropertiesInXML[\"Content-Length\"] === undefined ? undefined : parseFloat(blobPropertiesInXML[\"Content-Length\"]),\n    contentType: blobPropertiesInXML[\"Content-Type\"],\n    contentEncoding: blobPropertiesInXML[\"Content-Encoding\"],\n    contentLanguage: blobPropertiesInXML[\"Content-Language\"],\n    contentMD5: decodeBase64String(blobPropertiesInXML[\"Content-MD5\"]),\n    contentDisposition: blobPropertiesInXML[\"Content-Disposition\"],\n    cacheControl: blobPropertiesInXML[\"Cache-Control\"],\n    blobSequenceNumber: blobPropertiesInXML[\"x-ms-blob-sequence-number\"] === undefined ? undefined : parseFloat(blobPropertiesInXML[\"x-ms-blob-sequence-number\"]),\n    blobType: blobPropertiesInXML[\"BlobType\"],\n    leaseStatus: blobPropertiesInXML[\"LeaseStatus\"],\n    leaseState: blobPropertiesInXML[\"LeaseState\"],\n    leaseDuration: blobPropertiesInXML[\"LeaseDuration\"],\n    copyId: blobPropertiesInXML[\"CopyId\"],\n    copyStatus: blobPropertiesInXML[\"CopyStatus\"],\n    copySource: blobPropertiesInXML[\"CopySource\"],\n    copyProgress: blobPropertiesInXML[\"CopyProgress\"],\n    copyCompletedOn: blobPropertiesInXML[\"CopyCompletionTime\"] === undefined ? undefined : new Date(blobPropertiesInXML[\"CopyCompletionTime\"]),\n    copyStatusDescription: blobPropertiesInXML[\"CopyStatusDescription\"],\n    serverEncrypted: ParseBoolean(blobPropertiesInXML[\"ServerEncrypted\"]),\n    incrementalCopy: ParseBoolean(blobPropertiesInXML[\"IncrementalCopy\"]),\n    destinationSnapshot: blobPropertiesInXML[\"DestinationSnapshot\"],\n    deletedOn: blobPropertiesInXML[\"DeletedTime\"] === undefined ? undefined : new Date(blobPropertiesInXML[\"DeletedTime\"]),\n    remainingRetentionDays: blobPropertiesInXML[\"RemainingRetentionDays\"] === undefined ? undefined : parseFloat(blobPropertiesInXML[\"RemainingRetentionDays\"]),\n    accessTier: blobPropertiesInXML[\"AccessTier\"],\n    accessTierInferred: ParseBoolean(blobPropertiesInXML[\"AccessTierInferred\"]),\n    archiveStatus: blobPropertiesInXML[\"ArchiveStatus\"],\n    customerProvidedKeySha256: blobPropertiesInXML[\"CustomerProvidedKeySha256\"],\n    encryptionScope: blobPropertiesInXML[\"EncryptionScope\"],\n    accessTierChangedOn: blobPropertiesInXML[\"AccessTierChangeTime\"] === undefined ? undefined : new Date(blobPropertiesInXML[\"AccessTierChangeTime\"]),\n    tagCount: blobPropertiesInXML[\"TagCount\"] === undefined ? undefined : parseFloat(blobPropertiesInXML[\"TagCount\"]),\n    expiresOn: blobPropertiesInXML[\"Expiry-Time\"] === undefined ? undefined : new Date(blobPropertiesInXML[\"Expiry-Time\"]),\n    isSealed: ParseBoolean(blobPropertiesInXML[\"Sealed\"]),\n    rehydratePriority: blobPropertiesInXML[\"RehydratePriority\"],\n    lastAccessedOn: blobPropertiesInXML[\"LastAccessTime\"] === undefined ? undefined : new Date(blobPropertiesInXML[\"LastAccessTime\"]),\n    immutabilityPolicyExpiresOn: blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"] === undefined ? undefined : new Date(blobPropertiesInXML[\"ImmutabilityPolicyUntilDate\"]),\n    immutabilityPolicyMode: blobPropertiesInXML[\"ImmutabilityPolicyMode\"],\n    legalHold: ParseBoolean(blobPropertiesInXML[\"LegalHold\"])\n  };\n  return {\n    name: ParseBlobName(blobInXML[\"Name\"]),\n    deleted: ParseBoolean(blobInXML[\"Deleted\"]),\n    snapshot: blobInXML[\"Snapshot\"],\n    versionId: blobInXML[\"VersionId\"],\n    isCurrentVersion: ParseBoolean(blobInXML[\"IsCurrentVersion\"]),\n    properties: blobProperties,\n    metadata: blobInXML[\"Metadata\"],\n    blobTags: ParseBlobTags(blobInXML[\"Tags\"]),\n    objectReplicationMetadata: blobInXML[\"OrMetadata\"],\n    hasVersionsOnly: ParseBoolean(blobInXML[\"HasVersionsOnly\"])\n  };\n}\n\nfunction ParseBlobPrefix(blobPrefixInXML) {\n  return {\n    name: ParseBlobName(blobPrefixInXML[\"Name\"])\n  };\n}\n\nfunction ParseBlobTag(blobTagInXML) {\n  return {\n    key: blobTagInXML[\"Key\"],\n    value: blobTagInXML[\"Value\"]\n  };\n}\n\nfunction ParseBlobTags(blobTagsInXML) {\n  if (blobTagsInXML === undefined || blobTagsInXML[\"TagSet\"] === undefined || blobTagsInXML[\"TagSet\"][\"Tag\"] === undefined) {\n    return undefined;\n  }\n\n  const blobTagSet = [];\n\n  if (blobTagsInXML[\"TagSet\"][\"Tag\"] instanceof Array) {\n    blobTagsInXML[\"TagSet\"][\"Tag\"].forEach(blobTagInXML => {\n      blobTagSet.push(ParseBlobTag(blobTagInXML));\n    });\n  } else {\n    blobTagSet.push(ParseBlobTag(blobTagsInXML[\"TagSet\"][\"Tag\"]));\n  }\n\n  return {\n    blobTagSet: blobTagSet\n  };\n}\n\nexport function ProcessBlobItems(blobArrayInXML) {\n  const blobItems = [];\n\n  if (blobArrayInXML instanceof Array) {\n    blobArrayInXML.forEach(blobInXML => {\n      blobItems.push(ParseBlobItem(blobInXML));\n    });\n  } else {\n    blobItems.push(ParseBlobItem(blobArrayInXML));\n  }\n\n  return blobItems;\n}\nexport function ProcessBlobPrefixes(blobPrefixesInXML) {\n  const blobPrefixes = [];\n\n  if (blobPrefixesInXML instanceof Array) {\n    blobPrefixesInXML.forEach(blobPrefixInXML => {\n      blobPrefixes.push(ParseBlobPrefix(blobPrefixInXML));\n    });\n  } else {\n    blobPrefixes.push(ParseBlobPrefix(blobPrefixesInXML));\n  }\n\n  return blobPrefixes;\n} //# sourceMappingURL=utils.common.js.map","map":null,"metadata":{},"sourceType":"module"}